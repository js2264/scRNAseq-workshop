[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "",
    "text": "Welcome\nThis is the landing page of the workshop entitled Single-cell RNA-seq analysis with R/Bioconductor.\nA Docker image built from this repository is available here:\nüëâ ghcr.io/js2264/scrnaseqworkshop üê≥\nAn RStudio Server instance can be initiated from the Docker image as follows:\nbash\n\ndocker run \\\n    --volume &lt;local_folder&gt;:&lt;destination_folder&gt; \\\n    -e PASSWORD=OHCA \\\n    -p 8787:8787 \\\n    ghcr.io/js2264/scrnaseqworkshop:devel\nThe initiated RStudio Server instance will be available at https://localhost:8787.\nThe workshop content is available at this adress: https://github.com/js2264/scRNAseq-workshop.\nYou can clone it locally with git:\nTo download it without the command-line tool git, go to the GitHub repo page, click on the green Code button, then Download ZIP. Beware, the download may take a significant time based on your internet connection (several hundreds MB)."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Overview",
    "text": "Overview\nThis course will introduce biologists and bioinformaticians to the field of single-cell RNA sequencing. We will cover a range of software and analysis workflows that extend over the spectrum from the best practices in the filtering scRNA-seq data\nto the downstream analysis of cell clusters and temporal ordering. This course will help the attendees gain accurate insights in pre-processing, analysis and interpretation of scRNA-seq data.\nWe will start by introducing general concepts about single-cell RNA-sequencing. From there, we will then continue to describe the main analysis steps to go from raw sequencing data to processed and usable data. We will present classical analysis workflows, their output and the possible paths to investigate for downstream analysis.\nThroughout this workshop, we will put an emphasis on R/Bioconductor ecosystem and the different packages which will be used to analyse datasets and learn new approaches."
  },
  {
    "objectID": "index.html#format",
    "href": "index.html#format",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Format",
    "text": "Format\nThe course is structured in modules over five days.\nDuring the first 1/3 of the day, formal lectures will cover the key concepts required to understand the principles of scRNA-seq analysis (~2h).\nFollowing these lectures, practical examples will be shown to illustrate how to translate the acquired knowledge into functional R code (~1h). At this stage, trainees will get acquainted with state-of-the-art packages for scRNAseq analysis as well as the best practices in bioinformatics.\nDuring the second half of the day (3h), trainees will work by themselves, following guided exercises to improve their understanding of scRNAseq analysis workflow. Hints and solution are provided for each exercise. The exercises will mainly focus on specific concepts introducted earlier that day. However, analytical steps studied throughout the previous days will also be integrated so that towards the end of the week, trainees are fully able to perform fundamental scRNAseq analyses from beginning to end.\nOffice hours will take place during the last hour of the exercises. An instructor will be available to answer individual questions related to daily exercises. A Slack channel will also be available so that Q&A are available for everybody."
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Learning outcomes",
    "text": "Learning outcomes\nAt the end of this course, you should be able to:\n\nUnderstand the pros/cons of different single-cell RNA-seq methods\nProcess and QC of scRNA-seq data\nNormalize scRNA-seq data\nCorrect for batch effects\nVisualise the data and applying dimensionality reduction\nPerform cell clustering and annotation\nPerform differential gene expression analysis\nInfer cell trajectory and pseudotime, and perform temporal differential expression"
  },
  {
    "objectID": "index.html#instructor",
    "href": "index.html#instructor",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Instructor",
    "text": "Instructor\nDr.¬†Jacques Serizay"
  },
  {
    "objectID": "index.html#day-1",
    "href": "index.html#day-1",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Day 1",
    "text": "Day 1\n\n[1h] Lecture 1 - General introduction to single-cell RNA-seq experimental design [Pptx]\n[1h] Lecture 2 - scRNAseq: from raw sequencing files to count matrix [Pptx]\n[1h] Demonstration 1 - From fastq to count matrix [HTML | qmd (save to open in RStudio)]\n[3h] Homework - From bcl to count matrix [HTML | qmd (save to open in RStudio)]"
  },
  {
    "objectID": "index.html#day-2",
    "href": "index.html#day-2",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Day 2",
    "text": "Day 2\n\n[1h] Lecture 3 - Filtering cells in droplet-based scRNAseq data [Pptx]\n[1h] Lecture 4 - Normalizing scRNAseq data [Pptx]\n[BONUS] R/Bioconductor essentials: GRanges and *Experiment classes [Pptx]\n[1h] Demonstration 2 - Leveraging R/Bioconductor for single-cell analyses [HTML | qmd (save to open in RStudio)]\n[3h] Homework - scRNAseq analysis with R/Bioconductor (1/3) [HTML | qmd (save to open in RStudio)]"
  },
  {
    "objectID": "index.html#day-3",
    "href": "index.html#day-3",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Day 3",
    "text": "Day 3\n\n[2h] Lecture 5 - Clustering cells in scRNAseq [Pptx]\n[1h] Demonstration 3 - Dimensional reduction visualization and clustering [HTML | qmd (save to open in RStudio)]\n[3h] Homework - scRNAseq analysis with R/Bioconductor (2/3) [HTML | qmd (save to open in RStudio)]"
  },
  {
    "objectID": "index.html#day-4",
    "href": "index.html#day-4",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Day 4",
    "text": "Day 4\n\n[1h] Lecture 6 - Cell type annotations [Pptx]\n[1h] Lecture 7 - Batch correction [PDF]\n[1h] Demonstration 4 - Annotation transfer with scmap [HTML | qmd (save to open in RStudio)]\n[3h] Homework - scRNAseq analysis with R/Bioconductor (3/3) [HTML | qmd (save to open in RStudio)]"
  },
  {
    "objectID": "index.html#day-5",
    "href": "index.html#day-5",
    "title": "Single-cell RNA-seq workshop ed.¬†2024",
    "section": "Day 5",
    "text": "Day 5\n\n[2h] Lecture 8 - Trajectory inference and RNA velocity [Pptx]\n[1h] Demonstration 5 - Trajectory inference in multiciliated cells [HTML | qmd (save to open in RStudio)]\n[3h] Homework - Advanced scRNAseq topics: trajectory inference and RNA velocity [HTML | qmd (save to open in RStudio)]"
  },
  {
    "objectID": "Demonstration/Day1_demonstration.html#download-sequencing-reads-in-fastq-format",
    "href": "Demonstration/Day1_demonstration.html#download-sequencing-reads-in-fastq-format",
    "title": "Demonstration: From fastq to count matrix",
    "section": "1. Download sequencing reads in fastq format",
    "text": "1. Download sequencing reads in fastq format\nHere we will process a single-cell RNA-seq dataset provided by 10X Genomics, as an example.\nHere is the link to the dataset: link\nThis is a single-cell RNA-seq sample from mouse embryonic (E18) heart cells. Let‚Äôs first download the raw fastqs.\n\nmkdir -p data/E18_Heart/fastq\ncurl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/heart_1k_v3/heart_1k_v3_fastqs.tar -O data/E18_Heart/fastq/heart_1k_v3_fastqs.tar\ntar -xvf data/E18_Heart/fastq/heart_1k_v3_fastqs.tar\nmv heart_1k_v3_fastqs/ data/E18_Heart/fastq/\nls --color -ltFh data/E18_Heart/fastq/heart_1k_v3_fastqs\nzcat data/E18_Heart/fastq/heart_1k_v3_fastqs/heart_1k_v3_S1_L001_R1_001.fastq.gz | head\nzcat data/E18_Heart/fastq/heart_1k_v3_fastqs/heart_1k_v3_S1_L001_R2_001.fastq.gz | head\nzcat data/E18_Heart/fastq/heart_1k_v3_fastqs/heart_1k_v3_S1_L001_I1_001.fastq.gz | head"
  },
  {
    "objectID": "Demonstration/Day1_demonstration.html#prepare-genome-for-alignment",
    "href": "Demonstration/Day1_demonstration.html#prepare-genome-for-alignment",
    "title": "Demonstration: From fastq to count matrix",
    "section": "2. Prepare genome for alignment",
    "text": "2. Prepare genome for alignment\nDownload GRCm38 genome reference and gene annotations from iGenomes to ensure that genome reference and gene annotations are uniformly processed.\n\n# Download files\nmkdir data/E18_Heart/GRCm38/ && cd data/E18_Heart/GRCm38\ncurl http://igenomes.illumina.com.s3-website-us-east-1.amazonaws.com/Mus_musculus/Ensembl/GRCm38/Mus_musculus_Ensembl_GRCm38.tar.gz\ntar -xzvf Mus_musculus_Ensembl_GRCm38.tar.gz\n# Clean up gtf file to remove unscaffolded contigs\ngrep -vP \"^CHR|^GL|^JH\" Mus_musculus/Ensembl/GRCm38/Annotation/Genes/genes.gtf &gt; Mus_musculus/Ensembl/GRCm38/Annotation/Genes/genes_filtered.gtf\ncut -f1 Mus_musculus/Ensembl/GRCm38/Annotation/Genes/genes_filtered.gtf | uniq -c\n# Build cellranger index\ncellranger mkref \\\n    --genome=GRCm38 \\\n    --fasta=Mus_musculus/Ensembl/GRCm38/Sequence/WholeGenomeFasta/genome.fa \\\n    --genes=Mus_musculus/Ensembl/GRCm38/Annotation/Genes/genes_filtered.gtf \\\n    --nthreads=18 \\\n    --memgb=40\ncd ../../../\nls --color -lthF data/E18_Heart/GRCm38/GRCm38\n\nIf you fail to download/build Cellranger index, you can always get another version from here:\n\nwget https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz\n#md5sum: 886eeddde8731ffb58552d0bb81f533d\ntar -xzvf refdata-gex-mm10-2020-A.tar.gz\nls --color -lthF data/E18_Heart/GRCm38/GRCm38"
  },
  {
    "objectID": "Demonstration/Day1_demonstration.html#map-reads-onto-10x-formatted-genome-with-cellranger",
    "href": "Demonstration/Day1_demonstration.html#map-reads-onto-10x-formatted-genome-with-cellranger",
    "title": "Demonstration: From fastq to count matrix",
    "section": "3. Map reads onto 10X-formatted genome with cellranger",
    "text": "3. Map reads onto 10X-formatted genome with cellranger\n\nmkdir -p data/E18_Heart/cellranger && cd data/E18_Heart/cellranger\ncellranger count \\\n    --id=E18_Heart \\\n    --transcriptome=../../../data/E18_Heart/GRCm38/GRCm38 \\\n    --fastqs=../../../data/E18_Heart/fastq/heart_1k_v3_fastqs \\\n    --expect-cells=1000 \\\n    --localcores=18 \\\n    --localmem=40\ncd ../../\n\nMapping takes a significant amount of time. On my machine, it takes nearly ~ 1h to finish.\nThis should appear at the end of the mapping/counting process:\n\n## Outputs:\n## - Run summary HTML:                         E18_Heart/web_summary.html\n## - Run summary CSV:                          E18_Heart/metrics_summary.csv\n## - BAM:                                      E18_Heart/possorted_genome_bam.bam\n## - BAM index:                                E18_Heart/possorted_genome_bam.bam.bai\n## - Filtered feature-barcode matrices MEX:    E18_Heart/filtered_feature_bc_matrix\n## - Filtered feature-barcode matrices HDF5:   E18_Heart/filtered_feature_bc_matrix.h5\n## - Unfiltered feature-barcode matrices MEX:  E18_Heart/raw_feature_bc_matrix\n## - Unfiltered feature-barcode matrices HDF5: E18_Heart/raw_feature_bc_matrix.h5\n## - Secondary analysis output CSV:            E18_Heart/analysis\n## - Per-molecule read information:            E18_Heart/molecule_info.h5\n## - Loupe Browser file:                       E18_Heart/cloupe.cloupe\n## Waiting 6 seconds for UI to do final refresh.\n## Pipestance completed successfully!"
  },
  {
    "objectID": "Demonstration/Day1_demonstration.html#check-output-files",
    "href": "Demonstration/Day1_demonstration.html#check-output-files",
    "title": "Demonstration: From fastq to count matrix",
    "section": "4. Check output files",
    "text": "4. Check output files\nA description of the different output files is available here.\n\nls --color -lthF data/E18_Heart/cellranger/E18_Heart/\nls --color -lthF data/E18_Heart/cellranger/E18_Heart/outs\n\nWe can check the html summary report in a web browser to get more insights about the results of the scRNAseq experiment.\n\ndata/E18_Heart/cellranger/E18_Heart/outs/web_summary.html\n\nIf samtools is installed, one can also check the bam file obtained using cellranger count workflow.\n\nsamtools view data/E18_Heart/cellranger/E18_Heart/outs/possorted_genome_bam.bam | head -n 10\nsamtools flagstat data/E18_Heart/cellranger/E18_Heart/outs/possorted_genome_bam.bam\n\nThe analysis folder contains relevant(ish) information obtained from after a rough post-alignment processing of the dataset by cellranger.\n\ntree -L 2 data/E18_Heart/cellranger/E18_Heart/outs/analysis/\nhead data/E18_Heart/cellranger/E18_Heart/outs/analysis/clustering/graphclust/clusters.csv\ncut -f 2 -d, data/E18_Heart/cellranger/E18_Heart/outs/analysis/clustering/graphclust/clusters.csv | sort | uniq -c"
  },
  {
    "objectID": "Exercises/Day1_exercises.html#introduction-to-shell-terminal",
    "href": "Exercises/Day1_exercises.html#introduction-to-shell-terminal",
    "title": "Exercises: From bcl to count matrix",
    "section": "0. Introduction to shell terminal",
    "text": "0. Introduction to shell terminal\nshell (sh) is a software used to interpret commands typed in a terminal. It exists in both Mac and Linux environments.\nThe basic sh commands are useful to:\n\nNavigate within directories\nManage files organization\nLaunch command-line-based softwares (e.g.¬†cellranger)\n\nHere are some of the most important commands:\n\nCheck your working directory\n\n\npwd\n\n\nCheck history\n\n\nhistory\n\n\nput history into a history.txt file\n\n\nhistory &gt; history.txt\n\n\nmake a new folder called data\n\n\nmkdir data\n\n\nGo to the new data directory\n\n\ncd data\n\n\nmove history.txt file into data directory\n\n\nmv ../history.txt ./\n\n\ncheck manual page of curl command\n\n\nman curl\n\n\ncheck specific help for cellranger command and subcommands\n\n\ncellranger --help\ncellranger count --help\n\n\nredirect cellranger count help output into a file called cellranger-help.txt\n\n\n\ncellranger count --help &gt; cellranger-help.txt\n\n\nDownload a file from Internet with curl\n\n\n\ncurl https://cf.10xgenomics.com/supp/cell-exp/cellranger-tiny-bcl-1.2.0.tar.gz\n\n\nList all files in a folder\n\n\nls -l ~/\nls --color -Flh ~/"
  },
  {
    "objectID": "Exercises/Day1_exercises.html#prepare-a-place-in-your-computer-where-you-will-follow-the-workshop",
    "href": "Exercises/Day1_exercises.html#prepare-a-place-in-your-computer-where-you-will-follow-the-workshop",
    "title": "Exercises: From bcl to count matrix",
    "section": "1. Prepare a place in your computer where you will follow the workshop",
    "text": "1. Prepare a place in your computer where you will follow the workshop\nCreate a directory for the workshop\n\n\n\n\n\n\nQuestion\n\n\n\nOpen a terminal and navigate to your preferred location for the workshop.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Create a directory for the workshop \ncd ${HOME}\nmkdir scRNAseq_Jan24\ncd ${HOME}/scRNAseq_Jan24/\n\n\n\n\n\n\nFrom now on, everything you do should take place in this folder! Be sure you have enough storage space in the filesystem you are using, as you will need lots of it!\nClone github directory in the workshop directory\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the git repository for this course from GitHub\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncd ${HOME}/scRNAseq_Jan24/\ngit clone https://github.com/js2264/scRNAseq-workshop.git\n\n\n\n\n\n\nThis downloads the repository for this course to your home folder on the AWS machine.\nTo get it on your local computer (to save the lectures and exercises), you can also go to the GitHub repo page, click on the green Code button, then Download ZIP. Beware, the download may take a significant time based on your internet connection (several hundreds MB)."
  },
  {
    "objectID": "Exercises/Day1_exercises.html#process-raw-files-into-fastq-files",
    "href": "Exercises/Day1_exercises.html#process-raw-files-into-fastq-files",
    "title": "Exercises: From bcl to count matrix",
    "section": "2. Process raw files into fastq files",
    "text": "2. Process raw files into fastq files\nNOTE: This is a step typically performed internally by sequencing platform, which delivers .fastq files rather than .bcl files.\nFirst, familiarize yourself with cellranger mkfastq documentation: go to cellranger mkfastq webpage and read the Overview.\n\n\n\n\n\n\nQuestion\n\n\n\nWhat is the command you are going to use? What are the required and optional arguments for this command?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAn alternative to the web-based documentation is to use the command-line help:\n\ncellranger mkfastq --help\n\n\n\n\n\n\nGetting input toy dataset\nLet‚Äôs download a toy dataset to process into fastq files. A bcl tiny file is available and provided by 10X Genomics at the following adress: https://cf.10xgenomics.com/supp/cell-exp/cellranger-tiny-bcl-1.2.0.tar.gz.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the indicated bcl files and unzip it in a subdirectory called data/bcl2fastq/.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncd ${HOME}/scRNAseq_Jan24/\nmkdir -p data/bcl2fastq/\ncurl https://cf.10xgenomics.com/supp/cell-exp/cellranger-tiny-bcl-1.2.0.tar.gz -o data/bcl2fastq/cellranger-tiny-bcl-1.2.0.tar.gz\ntar -xzvf data/bcl2fastq/cellranger-tiny-bcl-1.2.0.tar.gz && mv cellranger-tiny-bcl-1.2.0/ data/bcl2fastq/\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nExplore the contents of the sequencing directory. What does each file correspond to? Can you locate the actual ‚Äúsequencing‚Äù files?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nls --color -ltFh data/bcl2fastq/cellranger-tiny-bcl-1.2.0\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nAlternatively, you can use the tree command (if available in your system!) to list the content of the cellranger-tiny-bcl-1.2.0 directory:\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ntree -L 4 data/bcl2fastq/cellranger-tiny-bcl-1.2.0/\n\n\n\n\n\n\nRunning cellranger mkfastq\n\n\n\n\n\n\n\nQuestion\n\n\n\nDo we have all the required files to run the cellranger mkfastq workflow? What about a samplesheet?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nNormally, when sequencing a library, a samplesheet is provided to the Illumina sequencing machine. In our case, we don‚Äôt have direct access to this sample sheet. Regardless, we can create one manually. Here are the info for the different samples which were sequenced in this toy dataset\n\necho \"Lane,Sample,Index\n1,test_sample1,SI-GA-E3\n1,test_sample2,SI-GA-F3\n1,test_sample3,SI-GA-G3\n1,test_sample4,SI-GA-H3\n\" &gt; data/bcl2fastq/cellranger-tiny-bcl-samplesheet.csv\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat does each column corresponds to? How is this going to be used when generating fastq files?\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nNow that we have a samplesheet ready, let‚Äôs launch the cellranger mkfastq workflow.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncd ${HOME}/scRNAseq_Jan24/data/bcl2fastq/\ncellranger mkfastq \\\n    --id=tiny-bcl \\\n    --run=cellranger-tiny-bcl-1.2.0/ \\\n    --csv=cellranger-tiny-bcl-samplesheet.csv\ncd ${HOME}/scRNAseq_Jan24/\n\n\n\n\n\n\nWatch out the memory usage! For mkfastq command with human genome, at least 32 Gb of RAM are required!\n\n\n\n\n\n\nQuestion\n\n\n\nWhat are the different files generated by this workflow?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOnce the conversion is achieved, the output folders can be viewed by running the ls command:\n\nls --color -ltFv data/bcl2fastq/tiny-bcl/\nls --color -ltFv data/bcl2fastq/tiny-bcl/outs/fastq_path/H35KCBCXY/test_sample1/\n### Or ...\ntree -L 3 data/bcl2fastq/tiny-bcl/\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nHow many fastq files have been generated? What does each one correspond to?\nLook at the index read (I1), read 1 (R1), and read (R2) files using the command zcat &lt;FASTQ_FILE_NAME&gt;.gz | head. What does each file contain?\nOpen the html file tiny-bcl/outs/fastq_path/Reports/html/index.html. Take some time to explore the demultiplexed outputs."
  },
  {
    "objectID": "Exercises/Day1_exercises.html#generate-gene-count-matrices-with-cellranger-count",
    "href": "Exercises/Day1_exercises.html#generate-gene-count-matrices-with-cellranger-count",
    "title": "Exercises: From bcl to count matrix",
    "section": "3. Generate gene count matrices with cellranger count",
    "text": "3. Generate gene count matrices with cellranger count\nFamiliarize yourself with the cellranger count documentation available here: cellranger count algorithm overview. Notably, read the section on Alignment (Read Trimming, Genome Alignment, MAPQ adjustment, Transcriptome Alignment, UMI Counting).\n\n\n\n\n\n\nQuestion\n\n\n\nWhich files are required for this step? Do we have all we need? Where is the index genome located?\n\n\nDownload genome index for the toy dataset\nmm10 pre-processed cellranger-formatted genome reference index is available here.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload it in a subdirectory named ${HOME}/scRNAseq_Jan24/\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncurl https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz -o refdata-gex-mm10-2020-A.tar.gz\ntar -xzvf refdata-gex-mm10-2020-A.tar.gz && mv refdata-gex-mm10-2020-A/ data/bcl2fastq/\n\n\nls --color -ltFh data/bcl2fastq/refdata-gex-mm10-2020-A/*\n\n\n\n\n\n\nRunning cellranger count\n\n\n\n\n\n\n\nQuestion\n\n\n\nIn the terminal, run the count command.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncd ${HOME}/scRNAseq_Jan24/data/bcl2fastq/\ncellranger count \\\n    --id=counts \\\n    --transcriptome=refdata-gex-mm10-2020-A \\\n    --fastqs=tiny-bcl/outs/fastq_path/ \\\n    --sample=test_sample1\n\n\n\n\n\n\nWhile the count command is running, read about the format of the feature-barcode matrices.\nChecking count output files\nOnce the count command is finished running, the pipeline outputs can be viewed as follows:\n\nls --color -ltFh counts/\nls --color -ltFh counts/outs/\n### Or ...\ntree -L 4 counts/\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCan you locate the feature-barcode matrices? What is the difference between the raw_feature_bc_matrix and filtered_feature_bc_matrix data types? In term of storage size?\nOpen the html file counts/outs/web_summary.html. Take some time to explore the gene expression matrix outputs.\nHow many clusters seem to be found? What are the main markers associated with each cluster?\nCan you speculate what the main difference(s) is between the clusters?\nDo the different metrics suggest that this sample contains good-quality data?"
  },
  {
    "objectID": "Exercises/Day1_exercises.html#alternative-generate-gene-count-matrices-with-starsolo",
    "href": "Exercises/Day1_exercises.html#alternative-generate-gene-count-matrices-with-starsolo",
    "title": "Exercises: From bcl to count matrix",
    "section": "3 [Alternative] Generate gene count matrices with STARsolo",
    "text": "3 [Alternative] Generate gene count matrices with STARsolo\n\n# Install STAR\nconda install -c bioconda star \n\n# Build STAR index\ncurl https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz -o refdata-gex-mm10-2020-A.tar.gz\ntar -xzvf refdata-gex-mm10-2020-A.tar.gz && mv refdata-gex-mm10-2020-A/ data/bcl2fastq/\nSTAR --runMode genomeGenerate --runThreadN 16 --genomeDir data/bcl2fastq/ --genomeFastaFiles data/bcl2fastq/refdata-gex-mm10-2020-A/fasta/genome.fa  --sjdbGTFfile data/bcl2fastq/refdata-gex-mm10-2020-A/genes/genes.gtf\nSTAR_GENOME_DIR=data/bcl2fastq/refdata-gex-mm10-2020-A/star/\n\n# Get barcode whitelist\ncurl https://raw.githubusercontent.com/10XGenomics/cellranger/master/lib/python/cellranger/barcodes/737K-august-2016.txt -o data/bcl2fastq/737K-august-2016.txt\nBC_WHITELIST_FILE=data/bcl2fastq/737K-august-2016.txt\n\n# Run STAR\nSTAR \\\n    --genomeDir \"${STAR_GENOME_DIR}\" \\\n    --soloType CB_UMI_Simple \\\n    --soloCBwhitelist \"${BC_WHITELIST_FILE}\" \\\n    --readFilesIn data/bcl2fastq/tiny-bcl/outs/fastq_path/Undetermined_S0_L001_R2_001.fastq.gz data/bcl2fastq/tiny-bcl/outs/fastq_path/Undetermined_S0_L001_R1_001.fastq.gz"
  },
  {
    "objectID": "Exercises/Day1_exercises.html#obtain-single-cell-rna-seq-datasets",
    "href": "Exercises/Day1_exercises.html#obtain-single-cell-rna-seq-datasets",
    "title": "Exercises: From bcl to count matrix",
    "section": "4. Obtain single-cell RNA-seq datasets",
    "text": "4. Obtain single-cell RNA-seq datasets\n‚ÄúThis is a course about single-cell RNA-seq analysis, right, so where is my data?‚Äù\nOk, ‚Äúyour‚Äù data is (most likely) yet to be sequenced! Or maybe you‚Äôre interested in digging already existing databases! I mean, who isn‚Äôt interested in this mind-blowing achievement from 10X Genomics??\nHuman Cell Atlas is probably a good place to start digging, if you are interested in mammal-related studies. For instance, let‚Äôs say I am interested in epididymis differentiation. Boom: here is an entry from the HCA focusing on epididymis: link to HCA data portal.\nRaw fastq reads from GEO\nHere is the link to the actual paper studying epididymis:An atlas of human proximal epididymis reveals cell-specific functions and distinct roles for CFTR.\n\n\n\n\n\n\nQuestion\n\n\n\nFind and check out the corresponding GEO entries for this study. What type of sequencing data is available?\n\n\nHere is the link to the GEO page: link.\n\n\n\n\n\n\nQuestion\n\n\n\nCan you find links to download the raw data from this paper?\n\n\nThere are several ways to find this information, e.g.¬†ffq command line tool, or using the web-based sra-explorer page (here). You generally will need the GEO corresponding ID or SRA project ID (e.g.¬†SRPxxxxxx‚Ä¶).\n\n\n\n\n\n\nQuestion\n\n\n\nTry to install and use ffq tool from the Patcher lab.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nconda install -c bioconda ffq\nffq --help\nffq -t GSE GSE148963\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you find the links to raw data associated with the GSE148963 GEO ID?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYou should use a grep command: grep returns the lines which match a given pattern (e.g.¬†a link‚Ä¶)!\n\nffq -t GSE GSE148963 | grep 'ftp://' \n\nAnd with a bit of sed magick‚Ä¶\n\nffq -t GSE GSE148963 | grep 'ftp://' | sed 's,.*ftp:,ftp:,' | sed 's,\".*,,' &gt; GSE148963_fastqlist.txt\n# wget -i GSE148963_fastqlist.txt ## Do not run, it would take too long...\n\n\n\n\n\n\n[BONUS] Pre-processed count matrices\nMany times, researchers will provide a filtered count matrix when they publish scRNAseq experiments (along with mandatory raw fastq data, of course). It‚Äôs way lighter than fastq reads, and you can go ahead with downstream analyses a lot quicker. So how do you get these matrices?\n\nHuman Cell Atlas Consortium provides many processed datasets. For instance, in our case, the Leir et al study is available at the following link: https://data.humancellatlas.org/explore/projects/842605c7-375a-47c5-9e2c-a71c2c00fcad.\nGEO also hosts processed files.\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nFind GEO-hosted processed files for the Leir et al study.\n\nYou can download some of the processed files available in GEO from the following webpage. Scrolling down to the bottom of the page, there is a box labelled ‚ÄúSupplementary data‚Äù. By clicking on ‚Äú(custom)‚Äù, a list of extra supplementary files will appear.\n\nDownload and check the content of the count matrix, the genes and the barcodes files.\n\nWhat type of information does each file contain? How is it formatted? is it easily imported in R?\n\nHow many cells were sequenced? How many genes were counted?\n\nIs it easy to interpret the count matrix? Why is it in such format?\n\nComment on the file sizes between processed count matrix files and raw reads."
  },
  {
    "objectID": "Demonstration/Day2_demonstration.html#installing-packages-in-r",
    "href": "Demonstration/Day2_demonstration.html#installing-packages-in-r",
    "title": "Demonstration: leveraging R/Bioconductor for single-cell analyses",
    "section": "1. Installing packages in R\n",
    "text": "1. Installing packages in R\n\n‚ÄúHey, I‚Äôve heard so many good things about this piece of software, it‚Äôs called ‚ÄòSeurat‚Äô? Heard of it? I wanna try it out soooo badly!‚Äù\nIn other words: ‚Äúhow do I install this or that brand new cutting-edge fancy package?‚Äù\nR works with packages, available from different sources:\n\n\nCRAN, the R developer team and official package provider: CRAN (which can probably win the title of ‚Äúthe worst webpage ever designed in 1982‚Äù).\n\nBioconductor, another package provider, with a primary focus on genomic-related packages: Bioconductor.\nOther unofficial sources, such as GitHub.\n\n\n\n\n\n\n\nQuestion\n\n\n\nInstall mgcv, HCAData and revelio packages\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nEach of these three packages is available from a different source.\n\ninstall.packages('mgcv')\nBiocManager::install('HCAData')\nremotes::install_github('danielschw188/revelio')\n\n\n\n\n\n\nPackage help pages are available at different places, depending on their source. That being said, there is a place I like to go to easily find information related to most packages:\nhttps://rdrr.io/\n\n\n\n\n\n\nQuestion\n\n\n\nFor instance, check out Revelio package help pages.\n\nWhat is this package designed for?\nWhat are its main functions? What type of input does it require?"
  },
  {
    "objectID": "Demonstration/Day2_demonstration.html#basic-r-and-bioconductor-classes",
    "href": "Demonstration/Day2_demonstration.html#basic-r-and-bioconductor-classes",
    "title": "Demonstration: leveraging R/Bioconductor for single-cell analyses",
    "section": "2. Basic R and Bioconductor classes",
    "text": "2. Basic R and Bioconductor classes\nWhile CRAN is a repository of general-purpose packages, Bioconductor is the greatest source of analytical tools, data and workflows dedicated to genomic projects in R. Read more about Bioconductor to fully understand how it builds up on top of R general features, especially with the specific classes it introduces.\nThe two main concepts behind Bioconductor‚Äôs success are the non-redundant classes of objects it provides and their inter-operability. Huber et al., Nat. Methods 2015 summarizes it well.\nImportant R concepts:\n\ntibble tables:\ntibbles are built on the fundamental data.frame objects. They follow ‚Äútidy‚Äù concepts, all gathered in a common tidyverse. This set of key concepts help general data investigation and data visualization through a set of associated packages such as ggplot2.\n\nlibrary(tidyverse)\ndat &lt;- tibble(\n    x = 1:5, \n    y = 1, \n    z = x ^ 2 + y, \n    class = c('a', 'a', 'b', 'b', 'c')\n)\ndat\n\nReading text files into tibbles\n\ntibbles can be created from text files (or Excel files) using the readr package (part of tidyverse)\n\ndir.create('data/R_101/')\ndownload.file('https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM4486nnn/GSM4486714/suppl/GSM4486714_AXH009_genes.tsv.gz', 'data/R_101/GSM4486714_AXH009_genes.tsv.gz')\ngenes &lt;- read_tsv('data/R_101/GSM4486714_AXH009_genes.tsv.gz', col_names = c('ID', 'Symbol'))\ngenes\n\nHandling of tibbles:\ntibbles can be readily ‚Äúsliced‚Äù (i.e.¬†selecting rows by number/name), ‚Äúfiltered‚Äù (i.e.¬†selecting rows by condition) and columns can be ‚Äúselected‚Äù. All these operations are performed using verbs (most of them provided by the dplyr package, part of tidyverse).\n\n# `slice` extract certain *rows* by integer location\nslice(genes, 1:4)\nslice_head(genes)\nslice_sample(genes, n = 10)\n# `filter` subsets the tibble, retaining all rows that satisfy your condition(s)\nfilter(genes, Symbol == 'CCDC67')\nfilter(genes, grepl('^CCDC.*', Symbol))\nfilter(genes, grepl('^CCDC.*', Symbol), grepl('.*5$', Symbol))\n# `select` extract `columns` by integer location, name, or pattern...\nselect(genes, 1)\nselect(genes, ID)\nselect(genes, matches('Sym.*'))\n\nColumns can also be quickly added/modified using the mutate verb.\n\n# `mutate` adds a new column\nmutate(genes, chr = sample(1:22, n(), replace = TRUE))\n\n\n%&gt;% pipe:\nActions on tibbles can be piped as a chain, just like | pipes stdout as the stdin of the next command in bash. In this case, the first argument is always the output of the previous function and is ommited. Because tidyverse functions generally return a modified version of the input, pipping works remarkably well in such context.\n\ngenes %&gt;% \n    mutate(chr = sample(1:22, n(), replace = TRUE)) %&gt;% \n    filter(chr == 2, grepl('^CCDC.*', Symbol)) %&gt;% \n    select(ID) %&gt;% \n    slice_head(n = 3)\n\nImportant Bioconductor concepts:\n\nSummarizedExperiment class:\nThe most fundamental class used to hold the content of large-scale quantitative analyses, such as counts of RNA-seq experiments, or high-throughput cytometry experiments or proteomics experiments.\n\nMake sure you understand the structure of objects from this class. A dedicated workshop that I would recommend quickly going over is available here. Generally speaking, a SummarizedExperiment object contains matrix-like objects (the assays), with rows representing features (e.g.¬†genes, transcripts, ‚Ä¶) and each column representing a sample. Information specific to genes and samples are stored in ‚Äúparallel‚Äù data frames, for example to store gene locations, tissue of expression, biotypes (for genes) or batch, generation date, or machine ID (for samples). On top of that, metadata are also stored in the object (to store description of a project, ‚Ä¶).\nAn important difference with S3 list-like objects usually used in R is most of the underlying data (organized in \"slots\") is accessed using getter functions, rather than the familiar $ or [. Here are some important getters:\n- `assay()`, `assays()`: Extrant matrix-like or list of matrix-like objects of identical dimensions. Since the objects are `matrix`-like, `dim()`, `dimnames()`, and 2-dimensional `[`, `[&lt;-` methods are available. \n- colData(): Annotations on each column (as a DataFrame): usually, description of each sample\n- rowData(): Annotations on each row (as a DataFrame): usually, description of each gene\n- metadata(): List of unstructured metadata describing the overall content of the object.\nLet‚Äôs dig into an example (you may need to install the airway package from Bioconductor‚Ä¶)\n\nlibrary(SummarizedExperiment)\n#BiocManager::install('airway')\nlibrary(airway)\ndata(airway)\nairway\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat are the dimensions of the dataset? What type of quantitative data is stored? Which features are assessed?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndim(airway)\nrowData(airway)\ncolData(airway)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you create a subset of the data corresponding to LRG genes in untreated samples?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nuntreated_LRG &lt;- airway[grepl('^LRG_', rownames(airway)), airway$dex == 'untrt']\nuntreated_LRG\n# Using tidyverse-like expression leveraging `tidySummarizedExperiment` pacakge: \nlibrary(tidySummarizedExperiment)\nairway\nfilter(airway, dex == 'untrt', grepl('^LRG_',  feature))\n\n\n\n\n\n\n\nGenomicRanges class (a.k.a. GRanges):\nGenomicRanges are a type of IntervalRanges, they are useful to describe genomic intervals. Each entry in a GRanges object has a seqnames(), a start() and an end() coordinates, a strand(), as well as associated metadata (mcols()). They can be built from scratch using tibbles converted with makeGRangesFromDataFrame().\n\nlibrary(GenomicRanges)\ngr &lt;- genes %&gt;% \n    mutate(\n        chr = sample(1:22, n(), replace = TRUE), \n        start = sample(1:1000, n(), replace = TRUE),\n        end = sample(10000:20000, n(), replace = TRUE),\n        strand = sample(c('-', '+'), n(), replace = TRUE)\n    ) %&gt;% \n    makeGRangesFromDataFrame(keep.extra.columns = TRUE)\ngr\nmcols(gr)\n\nJust like tidyverse in R, tidy functions are provided for GRanges by the plyranges package.\n\nlibrary(plyranges)\ngr %&gt;% \n    filter(start &lt; 400, end &gt; 12000, end &lt; 15000) %&gt;% \n    seqnames() %&gt;% \n    table()"
  },
  {
    "objectID": "Demonstration/Day2_demonstration.html#cran-bioconductor-approaches-to-scrnaseq",
    "href": "Demonstration/Day2_demonstration.html#cran-bioconductor-approaches-to-scrnaseq",
    "title": "Demonstration: leveraging R/Bioconductor for single-cell analyses",
    "section": "3. CRAN & Bioconductor approaches to scRNAseq",
    "text": "3. CRAN & Bioconductor approaches to scRNAseq\nscRNAseq in Bioconductor\nFor single-cell RNA-seq projects, Bioconductor has been introducting new classes and standards very rapidly in the past few years. Notably, several packages are increasingly becoming central for single-cell analysis:\n\nSingleCellExperiment\nscater\nscran\nscuttle\nbatchelor\nSingleR\nbluster\nDropletUtils\nslingshot\ntradeSeq\n‚Ä¶\n\nSingleCellExperiment is the fundamental class designed to contain single-cell (RNA-seq) data in Bioconductor ecosystem. It is a modified version of the SummarizedExperiment object, so most of the getters/setters are shared with this class.\n\nLet‚Äôs load a fully-fleged SingleCellExperiment object, so we can play around with it:\n\nlibrary(SingleCellExperiment)\nlibrary(tidySingleCellExperiment)\nsce &lt;- readRDS(url('https://github.com/js2264/scRNAseq-workshop/raw/main/pbmc3k.rds'), \"rb\")\nclass(sce)\nsce\n\nSeveral slots can be accessed in a SingleCellExperiment object, just like the SummarizedExperiment object it‚Äôs been adapted from:\n\ncolData(sce)\nrowData(sce)\nmetadata(sce)\ndim(sce)\nassays(sce)\n\nImportant slots for scRNAseq studies can also be accessed:\n\ncounts(sce)[1:10, 1:10]\nlogcounts(sce)[1:10, 1:10]\n\n\n\n\n\n\n\nQuestion\n\n\n\nCheck the colData() output of the sce object. What information is stored there? How can you access the different objects stored in colData?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncolData(sce)\nhead(colData(sce)[[1]])\nhead(colData(sce)[['sizeFactor']])\nhead(colData(sce)$sizeFactor)\nhead(sce$sizeFactor)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nAre there any reduced dimensionality representation of the data stored in the sce object? How many dimensions does each embedding contain?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nreducedDims(sce)\nhead(reducedDim(sce, 'PCA'))\nhead(reducedDim(sce, 'TSNE'))\nhead(reducedDim(sce, 'UMAP'))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nNow, plot the UMAP embedding and color cells by their cluster.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np &lt;- scater::plotReducedDim(sce, 'UMAP', colour_by = 'cluster', text_by = 'cluster')"
  },
  {
    "objectID": "Exercises/Day2_exercises.html#import-single-cell-rna-seq-data-in-r",
    "href": "Exercises/Day2_exercises.html#import-single-cell-rna-seq-data-in-r",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (1/3)",
    "section": "1. Import single-cell RNA-seq data in R",
    "text": "1. Import single-cell RNA-seq data in R\nImport data from cellranger workflow\nImporting 10X Genomics scRNAseq data in R can be done using DropletUtils package.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead the documentation for DropletUtils utilities useful for 10X Genomics data import here.\nDownload 1K mouse E18 heart scRNAseq filtered count matrix from 10X Genomics (in HDF5 format available here).\nImport it into R using read10xCounts() function.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndir.create('data/E18_Heart/cellranger/E18_Heart/')\ndownload.file(\n    url = 'https://cf.10xgenomics.com/samples/cell-exp/3.0.0/heart_1k_v3/heart_1k_v3_filtered_feature_bc_matrix.h5', \n    destfile = 'data/E18_Heart/cellranger/E18_Heart/heart_1k_v3_filtered_feature_bc_matrix.h5',\n    mode = 'wb'\n)\nheart &lt;- DropletUtils::read10xCounts('data/E18_Heart/cellranger/E18_Heart/heart_1k_v3_filtered_feature_bc_matrix.h5')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nHow many cells were sequenced in this dataset? How many genes are profiled?\nWhat is the distribution of genes being detected per cell, and of number of unique transcripts being detected per cell? And for each gene, what is the distribution of number of cells it is detected in? Use QC functions from the scuttle package to automatically compute these metrics.\nWhat is the sparsity of the data (in other words, how dense is the count matrix)?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Experiment size \ndim(heart)\n\n# Genes / transcripts detected per cell\nheart &lt;- scuttle::addPerCellQCMetrics(heart)\nheart &lt;- scuttle::addPerFeatureQCMetrics(heart)\nquantile(heart$sum, seq(0, 1, 0.1))\nquantile(heart$detected, seq(0, 1, 0.1))\nquantile(rowData(heart)$detected, seq(0, 1, 0.1))\n\n# Count matrix density\nsum(counts(heart) &gt; 0) / {dim(heart)[1] * dim(heart)[2]}\n\n\n\n\n\n\nUse ‚Äúpre-compiled‚Äù datasets\nThe scRNAseq package (from Bioconductor) allows one to import public datasets directly in R.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead the documentation vignette here.\nImport scRNAseq data from Zeisel et al., Science 2015 (doi: 10.1126/science.aaa1934) in R using the scRNAseq package.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nzeisel &lt;- scRNAseq::ZeiselBrainData()\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nHow many cells were sequenced in this dataset? How many genes are profiled?\nWhat is the distribution of genes being detected per cell, and of number of unique transcripts being detected per cell?\nWhat is the sparsity of the data (in other words, how dense is the count matrix)?\nCompare with 10X Genomics-provided data. Comment on the differences. What was the single-cell sequencing technique used in Zeisel et al.?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Experiment size \ndim(zeisel)\n\n# Genes / transcripts detected per cell\nzeisel &lt;- scuttle::addPerCellQCMetrics(zeisel)\nzeisel &lt;- scuttle::addPerFeatureQCMetrics(zeisel)\nquantile(zeisel$sum, seq(0, 1, 0.1))\nquantile(zeisel$detected, seq(0, 1, 0.1))\nquantile(rowData(zeisel)$detected, seq(0, 1, 0.1))\n\n# Count matrix density\nsum(counts(zeisel) &gt; 0) / {dim(zeisel)[1] * dim(zeisel)[2]}\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nWhat are the different annotations available for the cells?\nWhat are the tissues used for cell profiling? Which type of cells come from which tissue?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Check cell type annotations\ncolData(zeisel)\ntable(zeisel$level1class)\ntable(zeisel$level2class)\ntable(zeisel$level2class, zeisel$level1class)\n\n# Check tissue of origin\ntable(zeisel$tissue)\ntable(zeisel$level1class, zeisel$tissue)\n\n\n\n\n\n\nUMI number / cell\nA useful diagnostic for scRNAseq data is the barcode rank plot, which shows the (log-)total UMI count for each barcode on the y-axis and the (log-)rank on the x-axis. This is effectively a transposed empirical cumulative density plot with log-transformed axes. It is useful as it allows users to examine the distribution of total counts across barcodes, focusing on those with the largest counts.\nThis diagnostic plot can be generated using DropletUtils package, notably the barcodeRanks() function.\n\n\n\n\n\n\nQuestion\n\n\n\n\nTry to use barcodeRanks() function to compute and plot UMI # / cell across all the cells in either 10X Genomics-generated data or Zeisel‚Äôs data.\nComment the difference. Again, what are the important differences in term of single-cell approaches used here?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(tidyverse)\nheart_barcoderanks &lt;- DropletUtils::barcodeRanks(heart)\nzeisel_barcoderanks &lt;- DropletUtils::barcodeRanks(zeisel)\np &lt;- list(\n    heart = as_tibble(heart_barcoderanks), \n    zeisel = as_tibble(zeisel_barcoderanks)\n) %&gt;% \n    bind_rows(.id = 'dataset') %&gt;% \n    ggplot(aes(x = rank, y = total, group = dataset, col = dataset)) + \n    geom_line() + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    theme_bw() + \n    labs(x = 'Cells ranked by total UMI', y = 'Total UMI count / cell')"
  },
  {
    "objectID": "Exercises/Day2_exercises.html#filter-emtpy-and-doublet-droplets",
    "href": "Exercises/Day2_exercises.html#filter-emtpy-and-doublet-droplets",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (1/3)",
    "section": "2. Filter emtpy and doublet droplets",
    "text": "2. Filter emtpy and doublet droplets\nAn important step when getting your hands on droplet-based single-cell RNA-seq data is to be confident you are working with actual cell data. This means knowing how to deal with/remove (1) emtpy droplets and (2) droplets containing doublets.\nRemoving empty droplets\nThe ambient RNA ‚Äúsoup‚Äù sometimes makes it difficult to differentiate empty droplets from droplets containing cells with low amounts of RNA.\nemptyDrops() function from the DropletUtils package provides a methodology to (1) estimate the ambient RNA contamination and then (2) compute a probability that each droplet contains a cell.\nSince emptyDrops() assumes that most of the droplets in a matrix are empty, one needs to start the analysis from the raw unfiltered count matrix provided by 10X Genomics. Download the E18 mouse heart scRNAseq raw unfiltered count matrix from 10X Genomics here.\n\ndownload.file(\n    url = 'https://cf.10xgenomics.com/samples/cell-exp/3.0.0/heart_1k_v3/heart_1k_v3_raw_feature_bc_matrix.h5', \n    destfile = 'data/E18_Heart/cellranger/E18_Heart/heart_1k_v3_raw_feature_bc_matrix.h5', \n    mode = 'wb'\n)\nheart_raw &lt;- DropletUtils::read10xCounts('data/E18_Heart/cellranger/E18_Heart/heart_1k_v3_raw_feature_bc_matrix.h5')\nheart_raw\ndim(heart_raw)\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse emptyDrops() to differentiate empty droplets from cell-containing droplets.\nBe aware, the empty droplet detection step is quite lenghty! After all, you are scanning several millions of droplets, most of them empty! To fasten the process, you can specify a number of cpus to use in parallel, with the BiocParallel::MulticoreParam() function.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# emptyDrops performs Monte Carlo simulations to compute p-values, so we need to set the seed to obtain reproducible results.\nlibrary(DropletUtils)\nset.seed(100)\n# Do not run if not on an HPC cluster: \n# heart_droplets &lt;- emptyDrops(counts(heart_raw), BPPARAM = BiocParallel::MulticoreParam(workers = 40))\nheart_droplets\ntable(heart_droplets$FDR &lt;= 0.001)\nheart_filtered &lt;- heart_raw[, which(heart_droplets$FDR &lt;= 0.001)]\n\n\n\n\n\n\nEven with multiple cpus, the computation can take up to several hours. So if you wish to skip this step for now, you can use the cellranger-automatically filtered matrix for now. It is not exactly equivalent, but does a fairly good job at finding non-empty droplets and I would recommend sticking to it for the beginning.\n\nheart_filtered &lt;- heart\n\nFlagging cell doublets\nAnother artifact emerging from non-perfect experimental steps is the sequencing of two cells contained within a single droplet. This can occur when many cells are sequenced on a single 10X Genomics cassette (doublet increase of 1% per 1,000 cells sequenced). This can also occur when cells are not in a perfect single cell suspension.\nA way to identify cell doublets is to artifically mix thousands of pairs of cells (columns) of a SingleCellExperiment object, then compare the resulting cells to each cell in the original dataset. Original cells which resemble a lot the artificial doublets are likely doublet themselves.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead scDblFinder documentation here.\nUse scDblFinder() function to flag probable cell doublets in manually filtered heart dataset.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n#BiocManager::install('scDblFinder')\nlibrary(scDblFinder)\nheart_filtered &lt;- scDblFinder(heart_filtered)\ncolData(heart_filtered)\ntable(heart_filtered$scDblFinder.class)\n\n\n\n\n\n\nFor now, we can keep these doublets. We will see in the future whether we remove them or not."
  },
  {
    "objectID": "Exercises/Day2_exercises.html#optional-exclude-non-relevant-genes-from-analysis",
    "href": "Exercises/Day2_exercises.html#optional-exclude-non-relevant-genes-from-analysis",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (1/3)",
    "section": "3. (Optional) Exclude non-relevant genes from analysis",
    "text": "3. (Optional) Exclude non-relevant genes from analysis\nThe 10X Genomics-provided count matrix contains 31053 annotated genes. However, there are likely less than 20,000 of them which are genomic, protein-coding, expressed genes. We can filter genes based on the location, biotype and overall detection in the dataset.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRecover gene annotations as gtf from ensembl uing the AnnotationHub\n\nFilter to only get protein-coding, ENSEMBL+HAVANA-annotated genomic genes\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(plyranges)\nah &lt;- AnnotationHub::AnnotationHub()\nAnnotationHub::query(ah, c('gene annotation', 'ensembl', '102', 'mus_musculus', 'GRCm38'))\ngtf &lt;- AnnotationHub::query(ah, c('Mus_musculus.GRCm38.102.chr.gtf'))[[1]]\ngenes &lt;- gtf %&gt;% \n    filter(type == 'gene') %&gt;% \n    filter(gene_biotype == 'protein_coding') %&gt;% \n    filter(gene_source == 'ensembl_havana')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nFilter genes from the SingleCellExperiment dataset to only protein-coding, ENSEMBL+HAVANA-annotated genomic genes\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nnames(genes) &lt;- genes$gene_id\ntable(rownames(heart_filtered) %in% names(genes))\nheart_filtered &lt;- heart_filtered[rownames(heart_filtered) %in% names(genes), ]\ngr &lt;- genes[rownames(heart_filtered)]\nmcols(gr) &lt;- cbind(mcols(gr), rowData(heart_filtered))[, c('gene_id', 'gene_name', 'mean', 'detected')]\nrowRanges(heart_filtered) &lt;- gr\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nFilter remaining genes to only keep those detected in at least 10 cells\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nquantile(rowSums(counts(heart_filtered) &gt; 0), seq(0, 1, 0.1))\ntable( rowSums(counts(heart_filtered) &gt; 0) &gt;= 10 )\nheart_filtered &lt;- heart_filtered[rowSums(counts(heart_filtered) &gt; 0) &gt;= 10, ]"
  },
  {
    "objectID": "Exercises/Day2_exercises.html#normalize-data",
    "href": "Exercises/Day2_exercises.html#normalize-data",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (1/3)",
    "section": "4. Normalize data",
    "text": "4. Normalize data\nNormalization can be done two ways:\n\nA crude sequencing depth normalization followed by log-transformation. This is usually referred to as ‚Äúlog normalizing‚Äù.\nA more advanced (and probably more accurate) approach is the variance stabilizing transformation. This aims at removing the relationship between levels at which a gene is expressed and the variance of its expression.\n\nLog-normalization\nJust like in bulk high-throughput sequencing experiments, scRNAseq counts have to be normalized to the sequencing depth for each cell. We can define the library size (a.k.a. size factor )as the total sum of counts across all genes for each cell. However, this relies on the assumption that within the entire dataset, most genes are non-differentially expressed and expressed roughly within the same range. Depending on the set up of the scRNAseq experiment, this can be entirely false. To avoid relying on this hypothesis, we can (1) quickly pre-cluster cells, then (2) normalize cells using their library size factor separately in each cluster, then (3) rescaling size factors so that they are comparable across clusters.\n\n\n\n\n\n\nQuestion\n\n\n\nRead documentation for scran functions quickCluster() and computeSumFactors(). Compute size factors for each cell in the manually filtered E18 mouse heart scRNAseq dataset\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nclusters &lt;- scran::quickCluster(heart_filtered)\ntable(clusters)\nheart_filtered &lt;- scran::computeSumFactors(heart_filtered, cluster = clusters)\ncolData(heart_filtered)\nhead(heart_filtered$sizeFactor)\nquantile(heart_filtered$sizeFactor, seq(0, 1, 0.1))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCompare the size factor to the total count of UMI / cell. Comment.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nheart_filtered &lt;- scuttle::addPerCellQCMetrics(heart_filtered)\nheart_filtered &lt;- scuttle::addPerFeatureQCMetrics(heart_filtered)\np &lt;- tibble(\n    cell = heart_filtered$Barcode,\n    totUMIs = heart_filtered$total, \n    sizeFactor = heart_filtered$sizeFactor\n) %&gt;% \n    ggplot(aes(x = totUMIs, y = sizeFactor)) + \n    geom_point() + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    theme_bw() + \n    labs(x = 'Total UMI', y = 'Size factors')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUsing the computed size factors, perform log-normalization of the data. Read scuttle::logNormCounts() documentation if needed.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nheart_filtered &lt;- scuttle::logNormCounts(heart_filtered)\nassays(sce)\nlogcounts(heart_filtered)[1:10, 1:10]\np &lt;- tibble(\n    count = c(counts(heart_filtered)), \n    logcount = c(logcounts(heart_filtered))\n) %&gt;% \n    filter(count &gt; 0) %&gt;% \n    ggplot(aes(x = count, y = logcount)) + \n    ggrastr::geom_point_rast() + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    theme_bw() + \n    labs(x = 'Raw counts', y = 'log-normalized counts')\n\n\n\n\n\n\n[BONUS] VST normalization\n\n\n\n\n\n\nQuestion\n\n\n\n\nQuickly read the extensive vignette about scRNAseq normalization using variance stabilizing transformation here.\nFirst, check the relationship between (1) mean gene expression and gene expression variance and (2) mean gene expression and gene detection rate, in the manually filtered E18 mouse heart scRNAseq count matrix.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncnts &lt;- as(SingleCellExperiment::counts(heart_filtered), 'dgCMatrix')\ncolnames(cnts) &lt;- heart_filtered$Barcode\nrownames(cnts) &lt;- rownames(heart_filtered)\n#\ndf &lt;- tibble(\n    gene = rownames(cnts), \n    detection_rate = rowMeans(cnts &gt; 0),\n    mean = rowMeans(cnts), \n    variance = apply(cnts, 1, var)\n)\np1 &lt;- ggplot(df, aes(x = mean, y = variance)) + \n    geom_point(alpha = 0.3) + \n    geom_density_2d(size = 0.3) + \n    geom_abline(intercept = 0, slope = 1, color = \"red\") + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    labs(x = 'Gene expression mean', y = 'Gene expression variance') +\n    theme_bw() \np2 &lt;- ggplot(df, aes(x = mean, y = detection_rate)) + \n    geom_point(alpha = 0.3) + \n    geom_density_2d(size = 0.3) + \n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    labs(x = 'Gene expression mean', y = 'Gene detection rate') +\n    theme_bw() \np &lt;- cowplot::plot_grid(p1, p2, nrow = 1)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nApply sctransform::vst() function on raw counts from manually filtered E18 mouse heart scRNAseq count matrix.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nheart_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nUsing variance-stabilized residuals, correct the raw counts in the heart scRNAseq count matrix. You will need sctransform::correct() function to do this\nStore the corrected counts in an assay named corrected_counts\n\nLog-transform the corrected_counts using log1p() function and store the transformed counts in an assay named logcounts_vst\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncorrected_cnts &lt;- sctransform::correct(heart_vst)\nheart_filtered &lt;- heart_filtered[rownames(corrected_cnts),]\nassay(heart_filtered, 'corrected_counts', withDimnames = FALSE) &lt;- corrected_cnts\nassay(heart_filtered, 'logcounts_vst', withDimnames = FALSE) &lt;- log1p(corrected_cnts)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nOnce this is done, check again the relationship between mean gene expression and gene expression variance.\nCheck how the count variance now varies with increasing mean gene counts. Comment.\nCheck how the detection rate now varies with increasing mean gene counts. Comment.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndf &lt;- rbind(\n    tibble(\n        gene = rownames(cnts), \n        detection_rate = rowMeans(cnts &gt; 0),\n        mean = rowMeans(cnts), \n        variance = apply(cnts, 1, var), \n        normalization = 'raw'\n    ),\n    tibble(\n        gene = rownames(corrected_cnts), \n        detection_rate = rowMeans(corrected_cnts &gt; 0),\n        mean = rowMeans(corrected_cnts), \n        variance = apply(corrected_cnts, 1, var), \n        normalization = 'vst_corrected'\n    )\n)\np1 &lt;- ggplot(df, aes(x = mean, y = variance)) + \n    geom_point(alpha = 0.3) + \n    geom_density_2d(size = 0.3) + \n    geom_abline(intercept = 0, slope = 1, color = \"red\") + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    labs(x = 'Gene expression mean', y = 'Gene expression variance') +\n    theme_bw() + \n    facet_grid(~normalization) \np2 &lt;- ggplot(df, aes(x = mean, y = detection_rate)) + \n    geom_point(alpha = 0.3) + \n    geom_density_2d(size = 0.3) + \n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    labs(x = 'Gene expression mean', y = 'Gene detection rate') +\n    theme_bw() + \n    facet_grid(~normalization)\np &lt;- cowplot::plot_grid(p1, p2, nrow = 2)"
  },
  {
    "objectID": "Demonstration/Day3_demonstration.html#dimensionality-reduction",
    "href": "Demonstration/Day3_demonstration.html#dimensionality-reduction",
    "title": "Demonstration: Dimensional reduction visualization and clustering",
    "section": "1. Dimensionality reduction",
    "text": "1. Dimensionality reduction\nI am currently working on the differentiation of neural progenitor cells into multiciliated cells:\n\nLet‚Äôs load the data I have provided and inspect it:\n\nlibrary(SingleCellExperiment)\nlibrary(tidyverse)\n#\nMCCs &lt;- readRDS('data/MCCs/MCCs.rds')\nMCCs\ndim(MCCs)\ncolData(MCCs)\nrowData(MCCs)\nassays(MCCs)\nreducedDims(MCCs)\n\nTo perform PCA embedding, we need normalized data! Is this data normalized?\n\ncnts &lt;- as(assay(MCCs, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- MCCs$Barcode\nrownames(cnts) &lt;- rownames(MCCs)\ndf &lt;- tibble(\n    gene = rownames(cnts), \n    detection_rate = rowMeans(cnts &gt; 0),\n    mean = rowMeans(cnts), \n    variance = apply(cnts, 1, var)\n)\np &lt;- ggplot(df, aes(x = mean, y = variance)) + \n    geom_point(alpha = 0.3) + \n    geom_density_2d(size = 0.3) + \n    geom_abline(intercept = 0, slope = 1, color = \"red\") + \n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_x_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    labs(x = 'Gene expression mean', y = 'Gene expression variance') +\n    theme_bw() \nggsave('data/MCCs/variance~mean.pdf')\n\nThe gene expression variance is more or less equals to the gene average expression, as it should be assuming counts follow a Poisson distribution. This suggests that the data is probably already normalized!\nWe can now flag HVGs and use them for dimensionality reduction.\n\nassay(MCCs, 'logcounts') &lt;- log1p(counts(MCCs))\nMCCs_variance &lt;- scran::modelGeneVar(MCCs)\nMCCs_variance\nquantile(MCCs_variance$bio, seq(0, 1, 0.1))\nquantile(MCCs_variance$tech, seq(0, 1, 0.1))\n\nHVGs &lt;- scran::getTopHVGs(MCCs_variance, prop = 0.1)\nrowData(MCCs)$isHVG &lt;- rownames(MCCs) %in% HVGs\nhead(rowData(MCCs))\ntable(rowData(MCCs)$isHVG)\n\n# Visualizing the mean-variance fit, coloring HVGs\ndf &lt;- tibble(\n    mean = metadata(MCCs_variance)$mean, \n    var = metadata(MCCs_variance)$var, \n    trend = metadata(MCCs_variance)$trend(mean), \n    HVG = rowData(MCCs)$isHVG\n)\np &lt;- ggplot(df) + \n    geom_point(aes(x = mean, y = var, col = HVG), alpha = 0.4) + \n    geom_line(aes(x = mean, y = trend), col = 'darkred') +\n    theme_minimal() + \n    labs(x = 'Gene mean exp. (log1p)', y = 'Gene exp. variance')\nggsave('data/MCCs/variance~mean_HVGs.pdf')\n\nIs the default gene variance fitting approach good? Can we try out another approach?\n\nMCCs_CV &lt;- scran::modelGeneCV2(MCCs)\nMCCs_CV\nquantile(MCCs_CV$bio, seq(0, 1, 0.1))\nquantile(MCCs_CV$tech, seq(0, 1, 0.1))\n\nHVGs_2 &lt;- scran::getTopHVGs(MCCs_CV, prop = 0.1, var.field=\"ratio\")\nrowData(MCCs)$isHVG_2 &lt;- rownames(MCCs) %in% HVGs_2\nhead(rowData(MCCs))\ntable(rowData(MCCs)$isHVG_2)\n\n# Visualizing the mean-CV2 fit, coloring HVGs\ndf &lt;- tibble(\n    mean = metadata(MCCs_CV)$mean, \n    CV2 = metadata(MCCs_CV)$cv2, \n    trend = metadata(MCCs_CV)$trend(mean), \n    HVG = rowData(MCCs)$isHVG_2\n)\np &lt;- ggplot(df) + \n    geom_point(aes(x = mean, y = CV2, col = HVG), alpha = 0.4) + \n    geom_line(aes(x = mean, y = trend), col = 'darkred') +\n    scale_x_log10() + scale_y_log10() + \n    theme_minimal() + \n    labs(x = 'Gene mean exp.', y = 'Gene exp. CV2')\nggsave('data/MCCs/cv2~mean_HVGs.pdf')\n\nFitting gene expression CV2 ~ mean seems to be slightly more robust than gene expression variance ~ mean, here. We will use these HVGs for dimensionality reduction.\nNow we can embed in PCA:\n\nset.seed(1000)\nMCCs &lt;- scran::denoisePCA(\n    MCCs, \n    technical = MCCs_variance, \n    subset.row = HVGs_2, \n    min.rank = 15\n)\ndim(as.data.frame(reducedDim(MCCs)))\nhead(as.data.frame(reducedDim(MCCs)))\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'PCA', colour_by = 'detected'),\n    scater::plotReducedDim(MCCs, 'PCA', colour_by = 'sum')\n)\nggsave('data/MCCs/pca.pdf')"
  },
  {
    "objectID": "Demonstration/Day3_demonstration.html#cell-clustering",
    "href": "Demonstration/Day3_demonstration.html#cell-clustering",
    "title": "Demonstration: Dimensional reduction visualization and clustering",
    "section": "2. Cell clustering",
    "text": "2. Cell clustering\nWe can cluster cells (embedded in PCA space) using different methods:\n\na hierarchical clustering approach\na k-means approach\na graph-based approach\n\n\nset.seed(1000)\npca &lt;- reducedDim(MCCs, 'PCA')\nrownames(pca) &lt;- MCCs$Barcode\n\n# Hierarchical clustering\ndists &lt;- dist(pca)\nhclusts &lt;- hclust(dists)\nMCCs$cluster_hclust &lt;- factor(cutree(hclusts, k = 5))\n\n# k-means clustering\nkmeans &lt;- kmeans(pca, centers = 5)\nMCCs$cluster_kmeans &lt;- factor(kmeans$cluster)\n\n# Shared k-Nearest Neighbors graph clustering\ngraph &lt;- bluster::makeSNNGraph(pca)\ncommunities &lt;- igraph::cluster_louvain(graph)\nMCCs$cluster_SNN &lt;- factor(communities$membership)\n\n\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'PCA', colour_by = 'cluster_hclust', text_by = 'cluster_hclust') + ggtitle('PCA, hierarchical clusters'),\n    scater::plotReducedDim(MCCs, 'PCA', colour_by = 'cluster_kmeans', text_by = 'cluster_kmeans') + ggtitle('PCA, k-means clusters'),\n    scater::plotReducedDim(MCCs, 'PCA', colour_by = 'cluster_SNN', text_by = 'cluster_SNN') + ggtitle('PCA, SNN-graph clusters')\n)\nggsave('data/MCCs/clusters_PCA.pdf')\n\nWe can embed MCCs in UMAP space to better visualize the clusters\n\nset.seed(1000)\nMCCs &lt;- scater::runUMAP(MCCs)\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'cluster_hclust', text_by = 'cluster_hclust') + ggtitle('UMAP, hierarchical clusters'),\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'cluster_kmeans', text_by = 'cluster_kmeans') + ggtitle('UMAP, k-means clusters'),\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'cluster_SNN', text_by = 'cluster_SNN') + ggtitle('UMAP, SNN-graph clusters')\n)\nggsave('data/MCCs/clusters_UMAP.pdf')\n\nA new approach to check cell clustering is to leverage bluster package:\n\npca &lt;- reducedDim(MCCs, 'PCA')\nrownames(pca) &lt;- MCCs$Barcode\nevalClusters &lt;- bluster::bootstrapStability(pca, clusters = MCCs$cluster_SNN, mode = \"ratio\", BLUSPARAM = bluster::NNGraphParam())\npheatmap::pheatmap(evalClusters, breaks = seq(-1, 1, length=101), cluster_rows = FALSE, cluster_cols = FALSE)"
  },
  {
    "objectID": "Demonstration/Day3_demonstration.html#gene-expression-visualization",
    "href": "Demonstration/Day3_demonstration.html#gene-expression-visualization",
    "title": "Demonstration: Dimensional reduction visualization and clustering",
    "section": "3. Gene expression visualization",
    "text": "3. Gene expression visualization\nFirst we can order the clusters with a sensible order.\n\nlabels &lt;- c(\n    '1' = 'H', \n    '2' = 'G', \n    '3' = 'F', \n    '4' = 'D', \n    '5' = 'E', \n    '6' = 'C', \n    '7' = 'B', \n    '8' = \"B'\", \n    '9' = \"B'''\", \n    '10' = 'A'\n)\nMCCs$label &lt;- labels[MCCs$cluster_SNN]\n\nWe can check expression of known markers of MCC progenitors, or differentiating progenitors, or terminally differentiated progenitors.\n\ngenes &lt;- c(\n    'Mki67', \n    'Cdk1', \n    'Ube2c', \n    'Id3', 'Id4', \n    'Ccno', 'Mcidas', 'Cdc20b', \n    'Tmem212', 'Nnat'\n)\n\n# Plot clusters and gene expr. for a single gene\ngene &lt;- genes[[1]]\ndf &lt;- tibble(\n    UMAP1 = reducedDim(MCCs, 'UMAP')[, 1],\n    UMAP2 = reducedDim(MCCs, 'UMAP')[, 2],\n    annot = MCCs$label,\n    expr = as.vector(logcounts(MCCs[gene,])),\n)\np &lt;- cowplot::plot_grid(\n    ggplot(df, aes(x = UMAP1, y = UMAP2, col = annot)) + \n        ggrastr::geom_point_rast() + \n        ggtitle(gene) + \n        theme_bw(), \n    ggplot(df, aes(x = UMAP1, y = UMAP2, col = expr)) + \n        ggrastr::geom_point_rast() + \n        scale_color_distiller(palette = 'YlOrRd', direction = 1) + \n        theme_bw(), \n    ggplot(df, aes(x = annot, y = expr, fill = annot)) + \n        geom_violin(scale = 'width') + \n        theme_bw(), \n    nrow = 1, align = 'vh', axis = 'trbl'\n)\nggsave('data/MCCs/Mki67_UMAP.pdf', width = 10, height = 3)\n\n# Multiple genes in a `lapply` function\np &lt;- lapply(genes, function(gene) {\n    message(gene) \n    df &lt;- tibble(\n        UMAP1 = reducedDim(MCCs, 'UMAP')[, 1],\n        UMAP2 = reducedDim(MCCs, 'UMAP')[, 2],\n        annot = MCCs$label,\n        expr = as.vector(logcounts(MCCs[gene,])),\n    )\n    cowplot::plot_grid(\n        ggplot(df, aes(x = UMAP1, y = UMAP2, col = annot)) + \n            ggrastr::geom_point_rast() + \n            ggtitle(gene) + \n            theme_bw(), \n        ggplot(df, aes(x = UMAP1, y = UMAP2, col = expr)) + \n            ggrastr::geom_point_rast() + \n            scale_color_distiller(palette = 'YlOrRd', direction = 1) + \n            theme_bw(), \n        ggplot(df, aes(x = annot, y = expr, fill = annot)) + \n            geom_violin(scale = 'width') + \n            theme_bw(), \n        nrow = 1, align = 'vh', axis = 'trbl'\n    )\n}) %&gt;% cowplot::plot_grid(plotlist = ., ncol = 1)\nggsave('data/MCCs/gene-expr_UMAP.pdf', w = 15, h = 15)"
  },
  {
    "objectID": "Exercises/Day3_exercises.html#pre-processing-pbmc-dataset",
    "href": "Exercises/Day3_exercises.html#pre-processing-pbmc-dataset",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (2/3)",
    "section": "1. Pre-processing PBMC dataset",
    "text": "1. Pre-processing PBMC dataset\nWe will prepare scRNAseq data from a PBMC run, provided by 10X and hosted by Bioconductor as a package.\nPreparing dataset\n\n\n\n\n\n\nQuestion\n\n\n\n\nWhich package from Bioconductor gives streamlined access to PBMC scRNAseq dataset from 10X Genomics?\nImport the 4K PBMCs dataset provided by 10X Genomics directly in R.\nWhat does the object contain (type of data, number of cells, batches, organism, ‚Ä¶)?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npbmc &lt;- TENxPBMCData::TENxPBMCData('pbmc4k')\nrownames(pbmc) &lt;- scuttle::uniquifyFeatureNames(rowData(pbmc)$ENSEMBL_ID, rowData(pbmc)$Symbol_TENx)\npbmc\nrowData(pbmc)\ncolData(pbmc)\ntable(pbmc$Library)\n\n\n\n\n\n\nRemove doublets and filter non-relevant genes\n\n\n\n\n\n\nQuestion\n\n\n\nUse scDblFinder to flag and remove cell doublets\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npbmc &lt;- scDblFinder::scDblFinder(pbmc)\ntable(pbmc$scDblFinder.class)\npbmc &lt;- pbmc[, pbmc$scDblFinder.class == 'singlet']\n\n\n\n\n\n\nYou will then need to import gene annotations (from the right organism!) in R, to then filter out irrelevant genes.\n\n\n\n\n\n\nQuestion\n\n\n\n\nGet gene loci from Ensembl using AnnotationHub\n\nFilter to only get protein-coding, ENSEMBL+HAVANA-annotated genomic genes\nFurther remove genes that are not expressed in at least 10 cells\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Annotate genes in pbmc dataset\nlibrary(plyranges)\nah &lt;- AnnotationHub::AnnotationHub()\nAnnotationHub::query(ah, c('gene annotation', 'ensembl', '102', 'homo_sapiens', 'GRCh38'))\ngtf &lt;- AnnotationHub::query(ah, c('Homo_sapiens.GRCh38.102.chr.gtf'))[[1]]\ngenes &lt;- gtf %&gt;% \n    filter(type == 'gene') %&gt;% \n    filter(gene_biotype == 'protein_coding') %&gt;% \n    filter(gene_source == 'ensembl_havana')\n\npbmc &lt;- pbmc[genes$gene_id[genes$gene_id %in% rownames(pbmc)], ]\nrowRanges(pbmc) &lt;- genes[match(rownames(pbmc), genes$gene_id)]\nrowData(pbmc) &lt;- rowData(pbmc)[, c('gene_name', 'gene_id')]\nrownames(pbmc) &lt;- scuttle::uniquifyFeatureNames(rowData(pbmc)$gene_id, rowData(pbmc)$gene_name)\n\n# Genes / transcripts detected per cell\npbmc &lt;- scuttle::addPerCellQCMetrics(pbmc)\npbmc &lt;- scuttle::addPerFeatureQCMetrics(pbmc)\n\n# Remove genes not expressed in at least 10 cells\npbmc &lt;- pbmc[rowSums(counts(pbmc) &gt; 0) &gt;= 10, ]\n\n\n\n\n\n\nNormalize counts using sctransform\n\n\ncnts &lt;- as(SingleCellExperiment::counts(pbmc), 'dgCMatrix')\ncolnames(cnts) &lt;- pbmc$Barcode\nrownames(cnts) &lt;- rownames(pbmc)\npbmc_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\ncorrected_cnts &lt;- sctransform::correct(pbmc_vst)\nassay(pbmc, 'corrected_counts', withDimnames = FALSE) &lt;- corrected_cnts\nassay(pbmc, 'logcounts', withDimnames = FALSE) &lt;- log1p(corrected_cnts)"
  },
  {
    "objectID": "Exercises/Day3_exercises.html#dimensionality-reduction",
    "href": "Exercises/Day3_exercises.html#dimensionality-reduction",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (2/3)",
    "section": "2. Dimensionality reduction",
    "text": "2. Dimensionality reduction\nSelection of hyper-variable genes (HVGs)\nDimensionality reduction compare cells based on their gene expression profiles. The choice of genes to include in this comparison may have a major impact on the performance of downstream methods. Ideally, one wants to only select genes that contain useful information about the biology of the system while removing genes that contain random noise. This aims to preserve interesting biological structure without the variance that obscures that structure.\nThe simplest approach to feature selection is to simply compute the variance of the log-normalized expression values, to select the most variable genes. Modelling of the mean-variance relationship can be achieved by the modelGeneVar() function from the scran package.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead more about scran::modelGeneVar() online\n\nModel gene variance ~ gene average expression. What is the range of biological variance and technical variance?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Fit the gene variance as a function of the gene mean expression\npbmc_variance &lt;- scran::modelGeneVar(pbmc)\npbmc_variance\nquantile(pbmc_variance$bio, seq(0, 1, 0.1))\nquantile(pbmc_variance$tech, seq(0, 1, 0.1))\n\n# Visualizing the mean-variance fit\nrequire(tidyverse)\ndf &lt;- tibble(\n    mean = metadata(pbmc_variance)$mean, \n    var = metadata(pbmc_variance)$var, \n    trend = metadata(pbmc_variance)$trend(mean), \n)\np &lt;- ggplot(df) + \n    geom_point(aes(x = mean, y = var), alpha = 0.4) + \n    geom_line(aes(x = mean, y = trend), col = 'darkred') +\n    theme_minimal() + \n    labs(x = 'Gene mean exp. (norm.)', y = 'Gene exp. variance')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nExtract the 20% genes with the highest biological variance.\nPlot gene variance ~ gene average expression, coloring genes which are flagged as HVGs.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nHVGs &lt;- scran::getTopHVGs(pbmc_variance, prop = 0.1)\nrowData(pbmc)$isHVG &lt;- rownames(pbmc) %in% HVGs\nhead(rowData(pbmc))\ntable(rowData(pbmc)$isHVG)\n\n# Visualizing the mean-variance fit, coloring HVGs\ndf &lt;- tibble(\n    mean = metadata(pbmc_variance)$mean, \n    var = metadata(pbmc_variance)$var, \n    trend = metadata(pbmc_variance)$trend(mean), \n    HVG = rowData(pbmc)$isHVG\n)\np &lt;- ggplot(df) + \n    geom_point(aes(x = mean, y = var, col = HVG), alpha = 0.4) + \n    geom_line(aes(x = mean, y = trend), col = 'darkred') +\n    theme_minimal() + \n    labs(x = 'Gene mean exp. (norm.)', y = 'Gene exp. variance')\n\n\n\n\n\n\nEmbedding in a lower dimensional linear space\nWe now have normalized counts filtered for the top 20% genes varying with the greatest biological significance.\nStill, that represents a ~ 1,000 genes x ~4000 cells dataset. This is still too big to reliably use in standard clustering approaches. We can further compress the dataset. The most widely used approach is PCA: it computes a small number of ‚Äúcomponents‚Äù (typically 5-50) optimally summarizing the variability of the whole dataset, while retaining linearity of the underlying numerical data and being computationallt quite efficient.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead scater::denoisePCA() documentation. What is the benefit of this function compared to runPCA()?\nLeverage scater package to compute PCA embedding of the filtered data, by taking into account the technical variability.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npbmc &lt;- scran::denoisePCA(\n    pbmc, \n    technical = pbmc_variance, \n    subset.row = HVGs, \n    min.rank = 15\n)\ndim(as.data.frame(reducedDim(pbmc)))\nhead(as.data.frame(reducedDim(pbmc)))\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'detected'),\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'sum')\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCheck levels of gene expression for few genes (e.g.¬†CD8A, MS4A1, ‚Ä¶) using PCA embedding for visualization. Comment\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'CD8A'),\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'MS4A1'),\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'PPBP'),\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'FCER1A')\n)"
  },
  {
    "objectID": "Exercises/Day3_exercises.html#clustering",
    "href": "Exercises/Day3_exercises.html#clustering",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (2/3)",
    "section": "3. Clustering",
    "text": "3. Clustering\nClustering is an unsupervised learning procedure used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles. Its primary purpose is to summarize the data in a digestible format for human interpretation.\nAfter annotation based on marker genes, the clusters can be treated as proxies for more abstract biological concepts such as cell types or states. Clustering is thus a critical step for extracting biological insights from scRNA-seq data.\nClustering algorithms\nThree main approaches can be used:\n\nHierarchical clustering\nk-means clustering\nGraph-based clustering\n\nToday, we will focus on graph-based clustering, as it is becoming the standard for scRNAseq: it is a flexible and scalable technique for clustering even the largest scRNA-seq datasets. We first build a graph where each node is a cell that is connected by edges to its nearest neighbors in the high-dimensional space. Edges are weighted based on the similarity between the cells involved, with higher weight given to cells that are more closely related.\n\n\n\n\n\n\nQuestion\n\n\n\nCompute graph-based clustering of the PBMC dataset.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngraph &lt;- scran::buildSNNGraph(pbmc, use.dimred = 'PCA')\npbmc_clust &lt;- igraph::cluster_louvain(graph)$membership\ntable(pbmc_clust)\npbmc$clusters_graph &lt;- factor(pbmc_clust)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nWhat are the main parameters to choose? How do they impact the clustering?\nTry a non-default value for k argument. What is the impact on the clustering?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Re-compute a graph changing the `k` parameter, and identify resulting clusters\ngraph2 &lt;- scran::buildSNNGraph(pbmc, k = 50, use.dimred = 'PCA')\npbmc_clust2 &lt;- igraph::cluster_louvain(graph2)$membership\npbmc$clusters_graph_2 &lt;- factor(pbmc_clust2)\n\n# Compare original and new clusters\ntable(pbmc_clust, pbmc_clust2)\n\n# Visually compare original and new clusters\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'clusters_graph', text_by = 'clusters_graph') + ggtitle('SNN-graph clustering (louvain), k = 10'),\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'clusters_graph_2', text_by = 'clusters_graph_2') + ggtitle('SNN-graph clustering (louvain), k = 50')\n)\n\n\n\n\n\n\nDimensional reduction for clustering visualization\nPCA is a powerful linear approach to compress large datasets into smaller dimensional spaces. However, it struggles at emphasizing the existence of clusters in complex datasets, when visualized in 2D.\nscater provides a handy way to perform more complex data embeddings:\n- tSNE\n- UMAP\n- Diffusion Map\n- Multi-Dimensional Scaling (MDS)\n- Non-negative Matrix Factorization (NMF)\n\n\n\n\n\n\nQuestion\n\n\n\n\nExplore the different dimensional reduction algorithms, trying different hyperparameters combinations.\nWhen you run these commands, pay attention to how long each command takes to run!\nWhile this run, check the Help page for each function (e.g.¬†?scater::runTSNE)\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nreducedDims(pbmc)\npbmc &lt;- scater::runTSNE(pbmc)\npbmc &lt;- scater::runUMAP(pbmc)\npbmc &lt;- scater::runDiffusionMap(pbmc, dimred = 'PCA')\nreducedDims(pbmc)\nreducedDim(pbmc, 'DiffusionMap')[1:10, ]\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nUse the scater::plotReducedDim() function to plot cells in each embedding. Comment.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np&lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, 'PCA', colour_by = 'clusters_graph') + ggtitle('denoised PCA'),\n    scater::plotReducedDim(pbmc, 'TSNE', colour_by = 'clusters_graph') + ggtitle('tSNE'),\n    scater::plotReducedDim(pbmc, 'UMAP', colour_by = 'clusters_graph') + ggtitle('UMAP'),\n    scater::plotReducedDim(pbmc, 'DiffusionMap', colour_by = 'clusters_graph') + ggtitle('Diffusion') \n)"
  },
  {
    "objectID": "Demonstration/Day4_demonstration.html#integrating-two-replicates-together",
    "href": "Demonstration/Day4_demonstration.html#integrating-two-replicates-together",
    "title": "Demonstration: Cell type annotation and dataset integration",
    "section": "1. Integrating two replicates together",
    "text": "1. Integrating two replicates together\nWe have sequenced 2 replicates of WT cells differentiated into MCCs. Let‚Äôs process both datasets independantly.\n\nlibrary(SingleCellExperiment)\nlibrary(tidyverse)\nBl6J_WT &lt;- readRDS('data/MCCs/Bl6J_WT.rds')\nBl6N_WT &lt;- readRDS('data/MCCs/Bl6N_WT.rds')\nfuture::plan(strategy = \"multicore\", workers = 16)\nset.seed(1000)\n\n# Bl6J_WT\ncnts &lt;- as(assay(Bl6J_WT, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- Bl6J_WT$Barcode\nrownames(cnts) &lt;- rownames(Bl6J_WT)\nBl6J_WT_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\nBl6J_WT &lt;- Bl6J_WT[rownames(Bl6J_WT_vst$y), ]\nassay(Bl6J_WT, 'corrected_counts', withDimnames = FALSE) &lt;- sctransform::correct(Bl6J_WT_vst)\nassay(Bl6J_WT, 'logcounts', withDimnames = FALSE) &lt;- log1p(assay(Bl6J_WT, 'corrected_counts'))\nBl6J_WT_variance &lt;- scran::modelGeneVar(Bl6J_WT)\nHVGs &lt;- scran::getTopHVGs(Bl6J_WT_variance, prop = 0.1)\nBl6J_WT &lt;- scran::denoisePCA(Bl6J_WT, technical = Bl6J_WT_variance, subset.row = HVGs, min.rank = 15)\nBl6J_WT &lt;- scater::runUMAP(Bl6J_WT)\nBl6J_WT$cluster &lt;- factor(igraph::cluster_louvain(scran::buildSNNGraph(Bl6J_WT, use.dimred = 'PCA'))$membership)\n\n# Bl6N_WT\ncnts &lt;- as(assay(Bl6N_WT, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- Bl6N_WT$Barcode\nrownames(cnts) &lt;- rownames(Bl6N_WT)\nBl6N_WT_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\nBl6N_WT &lt;- Bl6N_WT[rownames(Bl6N_WT_vst$y), ]\nassay(Bl6N_WT, 'corrected_counts', withDimnames = FALSE) &lt;- sctransform::correct(Bl6N_WT_vst)\nassay(Bl6N_WT, 'logcounts', withDimnames = FALSE) &lt;- log1p(assay(Bl6N_WT, 'corrected_counts'))\nBl6N_WT_variance &lt;- scran::modelGeneVar(Bl6N_WT)\nHVGs &lt;- scran::getTopHVGs(Bl6N_WT_variance, prop = 0.1)\nBl6N_WT &lt;- scran::denoisePCA(Bl6N_WT, technical = Bl6N_WT_variance, subset.row = HVGs, min.rank = 15)\nBl6N_WT &lt;- scater::runUMAP(Bl6N_WT)\nBl6N_WT$cluster &lt;- factor(igraph::cluster_louvain(scran::buildSNNGraph(Bl6N_WT, use.dimred = 'PCA'))$membership)\n\n# Compare side-by-side\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(Bl6N_WT, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('Bl6N_WT'),\n    scater::plotReducedDim(Bl6J_WT, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('Bl6J_WT')\n)\nggsave('data/MCCs/WT-replicates_UMAP.pdf', w = 10, h = 5)\n\nProcess them together without genotype correction\n\nBl6J_WT &lt;- readRDS('data/MCCs/Bl6J_WT.rds')\nBl6N_WT &lt;- readRDS('data/MCCs/Bl6N_WT.rds')\n# Merge two genotypes\nMCCs &lt;- cbind(Bl6J_WT, Bl6N_WT)\nset.seed(1000)\n\n# Normalize counts with VST\ncnts &lt;- as(assay(MCCs, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- MCCs$Barcode\nrownames(cnts) &lt;- rownames(MCCs)\nMCCs_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\nMCCs &lt;- MCCs[rownames(MCCs_vst$y), ]\nassay(MCCs, 'corrected_counts', withDimnames = FALSE) &lt;- sctransform::correct(MCCs_vst)\nassay(MCCs, 'logcounts', withDimnames = FALSE) &lt;- log1p(assay(MCCs, 'corrected_counts'))\n# Flag HVGs\nMCCs_variance &lt;- scran::modelGeneVar(MCCs)\nHVGs &lt;- scran::getTopHVGs(MCCs_variance, prop = 0.1)\nrowData(MCCs)$HVG &lt;- rownames(MCCs) %in% HVGs\n# Embed in PCA\nMCCs &lt;- scran::denoisePCA(MCCs, technical = MCCs_variance, subset.row = HVGs, min.rank = 15)\nMCCs &lt;- scater::runUMAP(MCCs)\n# Cluster cells\nMCCs$cluster &lt;- factor(igraph::cluster_louvain(scran::buildSNNGraph(MCCs, use.dimred = 'PCA'))$membership)\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('MCCs'),\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'batch', text_by = 'cluster') + ggtitle('Genotype')\n)\nggsave('data/MCCs/WT-replicates-merged_UMAP.pdf', w = 10, h = 5)\n\nNow let‚Äôs do it again, but correcting for genotype.\n\nset.seed(1000)\nmergedBatches &lt;- batchelor::fastMNN(\n    MCCs, \n    batch = MCCs$batch, \n    subset.row = HVGs, \n    BPPARAM = BiocParallel::MulticoreParam(workers = 12)\n)\nmergedBatches\nrowData(mergedBatches)\nMCCs\nreducedDims(mergedBatches)\nreducedDim(MCCs, 'corrected_PCA') &lt;- reducedDim(mergedBatches, 'corrected')\nMCCs$corrected_cluster &lt;- factor(igraph::cluster_louvain(scran::buildSNNGraph(MCCs, use.dimred = 'corrected_PCA'))$membership)\nset.seed(1000)\nreducedDim(MCCs, 'corrected_UMAP') &lt;- scater::calculateUMAP(t(reducedDim(MCCs, 'corrected_PCA')))\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('MCCs'),\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'batch', text_by = 'batch') + ggtitle('Genotype'),\n    scater::plotReducedDim(MCCs, 'corrected_UMAP', colour_by = 'batch', text_by = 'batch') + ggtitle('Genotype'),\n    scater::plotReducedDim(MCCs, 'corrected_UMAP', colour_by = 'corrected_cluster', text_by = 'corrected_cluster') + ggtitle('MCCs')\n)\nggsave('data/MCCs/WT-replicates-corrected_UMAP.pdf', w = 10, h = 10)"
  },
  {
    "objectID": "Demonstration/Day4_demonstration.html#reading-ccnoko-dataset-in-r",
    "href": "Demonstration/Day4_demonstration.html#reading-ccnoko-dataset-in-r",
    "title": "Demonstration: Cell type annotation and dataset integration",
    "section": "2. Reading CcnoKO dataset in R",
    "text": "2. Reading CcnoKO dataset in R\nThere is a scRNAseq dataset of Ccno KO cells trying to undergo in vitro differentiation.\n\nCcnoKO &lt;- readRDS('data/MCCs/CcnoKO.rds')\nset.seed(1000)\n\n# Normalize counts with VST\ncnts &lt;- as(assay(CcnoKO, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- CcnoKO$Barcode\nrownames(cnts) &lt;- rownames(CcnoKO)\nCcnoKO_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\nCcnoKO &lt;- CcnoKO[rownames(CcnoKO_vst$y), ]\nassay(CcnoKO, 'corrected_counts', withDimnames = FALSE) &lt;- sctransform::correct(CcnoKO_vst)\nassay(CcnoKO, 'logcounts', withDimnames = FALSE) &lt;- log1p(assay(CcnoKO, 'corrected_counts'))\n# Flag HVGs\nCcnoKO_variance &lt;- scran::modelGeneVar(CcnoKO)\nHVGs &lt;- scran::getTopHVGs(CcnoKO_variance, prop = 0.1)\nrowData(CcnoKO)$HVG &lt;- rownames(CcnoKO) %in% HVGs\n# Embed in PCA\nCcnoKO &lt;- scran::denoisePCA(CcnoKO, technical = CcnoKO_variance, subset.row = HVGs, min.rank = 50)\nCcnoKO &lt;- scater::runUMAP(CcnoKO)\n# Cluster cells\nCcnoKO$cluster &lt;- factor(igraph::cluster_louvain(scran::buildSNNGraph(CcnoKO, use.dimred = 'PCA'))$membership)\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('CcnoKO'),\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'batch', text_by = 'cluster') + ggtitle('Genotype')\n)\nggsave('data/MCCs/CcnoKO_UMAP.pdf', w = 10, h = 5)"
  },
  {
    "objectID": "Demonstration/Day4_demonstration.html#annotating-ccnoko-dataset-with-wt-mccs-dataset-using-scmap",
    "href": "Demonstration/Day4_demonstration.html#annotating-ccnoko-dataset-with-wt-mccs-dataset-using-scmap",
    "title": "Demonstration: Cell type annotation and dataset integration",
    "section": "3. Annotating CcnoKO dataset with WT MCCs dataset using scmap\n",
    "text": "3. Annotating CcnoKO dataset with WT MCCs dataset using scmap\n\nWe have high-quality annotations for MCCs dataset, but not for CcnoKO dataset. Can we transfer annotations from MCCs to CcnoKO?\n\n# Prepare feature indices from MCCs\nset.seed(1000)\nrowData(MCCs)$feature_symbol &lt;- rowData(MCCs)$Symbol\nMCCs &lt;- scmap::selectFeatures(MCCs, suppress_plot = TRUE)\nMCCs &lt;- scmap::indexCluster(MCCs, cluster_col = 'annotation')\nmetadata(MCCs)\nhead(metadata(MCCs)[['scmap_cluster_index']])\n\n# Map clusters from MCCs onto CcnoKO\nset.seed(1000)\nrowData(CcnoKO)$feature_symbol &lt;- rowData(CcnoKO)$Symbol\nCcnoKO_scmap_clus &lt;- scmap::scmapCluster(\n    projection = CcnoKO, \n    index_list = list(yan = metadata(MCCs)$scmap_cluster_index)\n)\n\n# Get transferred annotations\nCcnoKO$annotation_projected &lt;- factor(CcnoKO_scmap_clus$combined_labs, levels = levels(MCCs$annotation))\n\n# Plot reduced dims\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'batch', text_by = 'batch') + ggtitle('CcnoKO'),\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'cluster', text_by = 'cluster') + ggtitle('Clusters'),\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'annotation_projected', text_by = 'annotation_projected') + ggtitle('Transferred annotations'),\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'annotation', text_by = 'annotation') + ggtitle('MCCs'),\n    ncol = 2\n)\nggsave('data/MCCs/CcnoKO-transferred-annotations_UMAP.pdf', w = 10, h = 10)"
  },
  {
    "objectID": "Demonstration/Day4_demonstration.html#mapping-ccnoko-onto-wt-mccs-cells",
    "href": "Demonstration/Day4_demonstration.html#mapping-ccnoko-onto-wt-mccs-cells",
    "title": "Demonstration: Cell type annotation and dataset integration",
    "section": "4. Mapping CcnoKO onto WT MCCs cells",
    "text": "4. Mapping CcnoKO onto WT MCCs cells\nAnother way to visualize which WT cell types the CcnoKO cells spatially overlap with is to project CcnoKO cells onto MCC cells in UMAP embedding. This could be done manually, by using the rotation matrix obtained from MCCs embedding in PCA space to ‚Äúlearn‚Äù PCA embedding of the CcnoKO data, etc‚Ä¶, however this process is rather hazardous when fastMNN() is first used to correct for batch bias.\nLuckily, this process is facilitated in Seurat, with the MapQuery() function. However, we do need to re-process most of the data in order to project CcnoKO cells onto WT MCC UMAP embedding.\n\n# Re-process each dataset separately with Seurat\nlibrary(Seurat)\noptions(future.globals.maxSize= 891289600)\nMCCs_seurat &lt;- as.Seurat(MCCs) %&gt;% \n    NormalizeData() %&gt;%\n    FindVariableFeatures(selection.method = \"vst\", nfeatures = 2000) %&gt;% \n    ScaleData() %&gt;% \n    RunPCA() %&gt;% \n    RunUMAP(reduction = \"pca\", dims = 1:30, return.model = TRUE)\nCcnoKO_seurat &lt;- as.Seurat(CcnoKO) %&gt;% \n    NormalizeData() %&gt;%\n    FindVariableFeatures(selection.method = \"vst\", nfeatures = 2000) %&gt;% \n    ScaleData() %&gt;% \n    RunPCA() %&gt;% \n    RunUMAP(reduction = \"pca\", dims = 1:30, return.model = TRUE)\n\n# Transfer anchors from MCCs to CcnoKO\nanchors &lt;- FindTransferAnchors(\n    reference = MCCs_seurat,\n    query = CcnoKO_seurat,\n    reference.reduction = \"pca\"\n)\n\n# Project CcnoKO onto MCCs UMAP embedding\nCcnoKO_seurat &lt;- MapQuery(\n    anchorset = anchors, \n    reference = MCCs_seurat, \n    query = CcnoKO_seurat, \n    reference.reduction = \"pca\", \n    reduction.model = \"umap\"\n)\n\n# Exporting back the learnt UMAP to CcnoKO\nreducedDim(MCCs, 'learnt_UMAP') &lt;- Embeddings(MCCs_seurat, reduction = \"umap\")\nreducedDim(CcnoKO, 'learnt_UMAP') &lt;- Embeddings(CcnoKO_seurat, reduction = \"ref.umap\")\n\n# Plot new embeddings\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, 'UMAP', colour_by = 'annotation', text_by = 'annotation') + ggtitle('MCCs, original UMAP'),\n    scater::plotReducedDim(MCCs, 'learnt_UMAP', colour_by = 'annotation', text_by = 'annotation') + ggtitle('MCCs, UMAP from Seurat'),\n    scater::plotReducedDim(CcnoKO, 'UMAP', colour_by = 'annotation_projected', text_by = 'annotation_projected') + ggtitle('CcnoKO, original UMAP'),\n    scater::plotReducedDim(CcnoKO, 'learnt_UMAP', colour_by = 'annotation_projected', text_by = 'annotation_projected') + ggtitle('CcnoKO, learnt UMAP'),\n    ncol = 2\n)\nggsave('data/MCCs/CcnoKO-projected_UMAP.pdf', w = 10, h = 10)"
  },
  {
    "objectID": "Exercises/Day4_exercises.html#pre-processing-pbmc-dataset",
    "href": "Exercises/Day4_exercises.html#pre-processing-pbmc-dataset",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (3/3)",
    "section": "0. Pre-processing PBMC dataset",
    "text": "0. Pre-processing PBMC dataset\nDuring the previous day, the homeworks focused on processing 4K PBMC dataset to obtain main cell clusters. Here are the main commands to process this dataset.\n\nset.seed(1000)\n# Importing 4K PBMC data from 10X Genomics in R\npbmc &lt;- TENxPBMCData::TENxPBMCData('pbmc4k')\nrownames(pbmc) &lt;- scuttle::uniquifyFeatureNames(rowData(pbmc)$ENSEMBL_ID, rowData(pbmc)$Symbol_TENx)\n\n# Remove doublets\npbmc &lt;- scDblFinder::scDblFinder(pbmc)\npbmc &lt;- pbmc[, pbmc$scDblFinder.class == 'singlet']\n\n# Recover human genomic, protein-coding gene informations\nlibrary(plyranges)\nah &lt;- AnnotationHub::AnnotationHub()\nAnnotationHub::query(ah, c('gene annotation', 'ensembl', '102', 'homo_sapiens', 'GRCh38'))\ngtf &lt;- AnnotationHub::query(ah, c('Homo_sapiens.GRCh38.102.chr.gtf'))[[1]]\ngenes &lt;- gtf %&gt;% \n    filter(type == 'gene') %&gt;% \n    filter(gene_biotype == 'protein_coding') %&gt;% \n    filter(gene_source == 'ensembl_havana')\n\n# Annotate genes in PBMC dataset and filter out non-relevant genes\npbmc &lt;- pbmc[genes$gene_name[genes$gene_name %in% rownames(pbmc)], ]\nrowRanges(pbmc) &lt;- genes[match(rownames(pbmc), genes$gene_name)]\nrowData(pbmc) &lt;- rowData(pbmc)[, c('gene_name', 'gene_id')]\nrownames(pbmc) &lt;- scuttle::uniquifyFeatureNames(rowData(pbmc)$gene_id, rowData(pbmc)$gene_name)\n\n# Get preliminary QCs per cell and per gene\npbmc &lt;- scuttle::addPerCellQCMetrics(pbmc)\npbmc &lt;- scuttle::addPerFeatureQCMetrics(pbmc)\n\n# Filter out genes not expressed in at least 10 cells\npbmc &lt;- pbmc[rowSums(counts(pbmc) &gt; 0) &gt;= 10, ]\n\n# Normalize counts using VST\ncnts &lt;- as(SingleCellExperiment::counts(pbmc), 'dgCMatrix')\ncolnames(cnts) &lt;- pbmc$Barcode\nrownames(cnts) &lt;- rownames(pbmc)\npbmc_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\ncorrected_cnts &lt;- sctransform::correct(pbmc_vst)\nassay(pbmc, 'corrected_counts', withDimnames = FALSE) &lt;- corrected_cnts\nassay(pbmc, 'logcounts', withDimnames = FALSE) &lt;- log1p(corrected_cnts)\n\n# Computing biological variance of each gene\npbmc_variance &lt;- scran::modelGeneVar(pbmc)\nHVGs &lt;- scran::getTopHVGs(pbmc_variance, prop = 0.1)\nrowData(pbmc)$isHVG &lt;- rownames(pbmc) %in% HVGs\n\n# Embedding dataset in PCA space and removing technical variance\npbmc &lt;- scran::denoisePCA(\n    pbmc, \n    technical = pbmc_variance, \n    subset.row = HVGs, \n    min.rank = 15\n)\n\n# Embedding dataset in shared k-nearest neighbors graph for clustering \ngraph &lt;- scran::buildSNNGraph(pbmc, use.dimred = 'PCA')\n\n# Cluster cells using Louvain community finding algorithm\npbmc_clust &lt;- igraph::cluster_louvain(graph)$membership\ntable(pbmc_clust)\npbmc$clusters_graph &lt;- factor(pbmc_clust)\n\n# Embedding dataset in t-SNE space for visualization\npbmc &lt;- scater::runTSNE(pbmc)"
  },
  {
    "objectID": "Exercises/Day4_exercises.html#differential-expression-analysis-and-marker-genes",
    "href": "Exercises/Day4_exercises.html#differential-expression-analysis-and-marker-genes",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (3/3)",
    "section": "1. Differential expression analysis and marker genes",
    "text": "1. Differential expression analysis and marker genes\nTo interpret clustering results, one needs to identify the genes that drive separation between clusters. These marker genes allow to assign biological meaning to each cluster based on their functional annotation. In the most obvious case, the marker genes for each cluster are a priori associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.\nA general strategy is to perform DE tests between pairs of clusters and then combine results into a single ranking of marker genes for each cluster.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead scran::findMarkers() documentation\nRun the function on the PBMC dataset to find all the markers associated with individual graph-based clusters.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmarkers &lt;- scran::findMarkers(pbmc, groups = pbmc$clusters_graph)\nmarkers %&gt;% \n    as('list') %&gt;% \n    map(function(x){as_tibble(x, rownames = 'gene') %&gt;% filter(Top &lt;= 5)}) %&gt;% \n    bind_rows(.id = 'cluster')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nRe-run scran::findMarkers() to only find markers strongly overexpressed in each cluster.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmarkers &lt;- scran::findMarkers(\n    pbmc, \n    groups = pbmc$clusters_graph, \n    direction = \"up\", \n    lfc = 1\n)\nhead(markers[[1]])\nmarkers %&gt;% \n    as('list') %&gt;% \n    map(function(x){as_tibble(x, rownames = 'gene') %&gt;% filter(Top &lt;= 5)}) %&gt;% \n    bind_rows(.id = 'cluster')\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nPlot average expression of the first marker of the first cluster in tSNE\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np &lt;- scater::plotReducedDim(pbmc, 'TSNE', colour_by = rownames(markers[[1]])[1])\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCheck knwon PBMC markers in the Human Protein Atlas, which compiles a very nice overview of gene expression in different cell types, e.g.¬†here.\nLooking at these PBMC markers in the dataset, speculate to propose a label for each cluster in this 4K PBMC dataset.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmarkers &lt;- c(\n    'FCER1A', # DC markers\n    'GNLY', # NK markers\n    'PPBP', # Platelets markers\n    'MS4A7', # Monocytes markers\n    'MS4A1', # B cell markers\n    'IL7R', # CD4 T cell markers\n    'CD8A', 'CD8B' # CD8 T cell markers\n)\np &lt;- lapply(markers, function(g) {\n    scater::plotReducedDim(pbmc, 'TSNE', colour_by = g) + ggtitle(g) + theme(legend.position = 'none') + theme_bw()\n}) %&gt;% cowplot::plot_grid(plotlist = .)"
  },
  {
    "objectID": "Exercises/Day4_exercises.html#automated-cell-annotation",
    "href": "Exercises/Day4_exercises.html#automated-cell-annotation",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (3/3)",
    "section": "2. Automated cell annotation",
    "text": "2. Automated cell annotation\nMany human cell type reference databases are available over the Internet, especially for blood tissue. Today, we will use a reference constructed from Monaco et al., Cell Reports 2019 (doi: 10.1016/j.celrep.2019.01.041). This reference is available as a SummarizedExperiment containing log-normalized gene expression for manually annotated samples.\n\n\n\n\n\n\nQuestion\n\n\n\n\nImport Monaco dataset in R. Inspect its content. The structure of the object should feel familiar: it‚Äôs a Summarized Experiment!\nCheck the publication report. How was each sample (column) obtained? What type of sequencing?\nWhat types of cell annotation are available? Can this reference be useful for the annotation of the PBMC dataset?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmonaco &lt;- celldex::MonacoImmuneData()\nmonaco\ndim(monaco)\ncolData(monaco)\nrowData(monaco)\ntable(monaco$label.main)\ntable(monaco$label.fine)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead SingleR documentation. Can it be leveraged to transfer reference annotations to PBMC dataset?\nUse SingleR to transfer reference annotations to PBMC dataset.\nCheck how transferred annotations recapitulate manual graph-based clustering.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npredictions_main &lt;- SingleR::SingleR(\n    test = pbmc, \n    ref = monaco, \n    labels = monaco$label.main\n)\npredictions_fine &lt;- SingleR::SingleR(\n    test = pbmc, \n    ref = monaco, \n    labels = monaco$label.fine\n)\npbmc$annotation_hierarchy_1 &lt;- predictions_main$labels\npbmc$annotation_hierarchy_2 &lt;- predictions_fine$labels\ntable(pbmc$annotation_hierarchy_1)\ntable(pbmc$annotation_hierarchy_2)\ntable(pbmc$annotation_hierarchy_1, pbmc$clusters_graph)\ntable(pbmc$annotation_hierarchy_2, pbmc$annotation_hierarchy_1)\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, dimred = 'TSNE', colour_by = 'clusters_graph', text_by = 'clusters_graph') + ggtitle('Graph-based clusters'), \n    scater::plotReducedDim(pbmc, dimred = 'TSNE', colour_by = 'annotation_hierarchy_1', text_by = 'annotation_hierarchy_1') + ggtitle('Annotations (main) transferred from Monaco et al.'),\n    scater::plotReducedDim(pbmc, dimred = 'TSNE', colour_by = 'annotation_hierarchy_2', text_by = 'annotation_hierarchy_2') + ggtitle('Annotations (fine) transferred from Monaco et al.')\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nUsing scater and SingleR utilities, check the annotation score for each cell in the scRNAseq. Did the automated annotation work robuslty?\nIs automated annotation as sensitive as graph-based clustering, in this context?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np &lt;- SingleR::plotScoreHeatmap(predictions_fine)\np &lt;- pheatmap::pheatmap(\n    log2(table(Assigned = pbmc$annotation_hierarchy_2, Cluster = pbmc$clusters_graph)+10), \n    color=colorRampPalette(c(\"white\", \"darkred\"))(101)\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nUsing main and fine annotations, label each cluster in 2 lists of hierarchical labels\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhierarchy_1 &lt;- c(\n    '1' = 'DC', \n    '2' = 'DC', \n    '3' = 'B', \n    '4' = 'NK', \n    '5' = 'Mono', \n    '6' = 'T', \n    '7' = 'Mono', \n    '8' = 'T', \n    '9' = 'T', \n    '10' = 'T', \n    '11' = 'Mono'\n)\nhierarchy_2 &lt;- c(\n    '1' = 'Myel. DC', \n    '2' = 'Plasma. DC', \n    '3' = 'B', \n    '4' = 'NK', \n    '5' = 'Inter./non-classic Mono', \n    '6' = 'Helper T', \n    '7' = 'Classical Mono', \n    '8' = 'Eff. CD8 T', \n    '9' = 'Naive T', \n    '10' = 'Naive T', \n    '11' = 'Classical Mono'\n)\npbmc$label_hierarchy_1 &lt;- hierarchy_1[as.character(pbmc$clusters_graph)]\npbmc$label_hierarchy_2 &lt;- hierarchy_2[as.character(pbmc$clusters_graph)]\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(pbmc, dimred = 'TSNE', colour_by = 'label_hierarchy_1', text_by = 'label_hierarchy_1') + ggtitle('Cluster labels, level 1'),\n    scater::plotReducedDim(pbmc, dimred = 'TSNE', colour_by = 'label_hierarchy_2', text_by = 'label_hierarchy_2') + ggtitle('Cluster labels, level 2')\n)\n\n\n\n\n\n\nNote how cells from cluster 1 and 2 are both robustly identifed as DCs. Yet, they appear in tSNE as 2 well-separated clusters. This discrepancy most likely comes from the fact that at a finer level, they seem to be 2 different types of DCs: plasmacytoid DCs and myeloid DCs.\n\n\n\n\n\n\nQuestion\n\n\n\n\nCheck genes preferentially enriched in plasma. DCs vs myeloid DCs\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nDCs &lt;- pbmc[ , pbmc$label_hierarchy_1 == 'DC']\nmarkers &lt;- scran::findMarkers(\n    DCs, \n    groups = DCs$label_hierarchy_2, \n    direction = \"up\", \n    lfc = 1\n)\nmarkers[[2]] %&gt;% \n    as_tibble(rownames = 'gene') %&gt;% \n    dplyr::filter(summary.logFC &gt; log2(2), FDR &lt;= 0.01)"
  },
  {
    "objectID": "Exercises/Day4_exercises.html#subclustering-of-t-cells",
    "href": "Exercises/Day4_exercises.html#subclustering-of-t-cells",
    "title": "Exercises: scRNAseq analysis with R/Bioconductor (3/3)",
    "section": "3. Subclustering of T cells",
    "text": "3. Subclustering of T cells\nT cells are spatially separated in 2 or 3 broad groups. However, their complexity is much more important than this. Despite the fine annotations obtained from transfer of Monaco data, T cells heterogeneity are poorly resolved.\n\n\n\n\n\n\nQuestion\n\n\n\n\nSubset the T cells and re-process them (variance modelling, PCA embedding, graph-based clustering and tSNE embedding)\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nTcells &lt;- pbmc[ , pbmc$label_hierarchy_1 == 'T']\n\n# Computing biological variance of each gene\nset.seed(1000)\nTcells_variance &lt;- scran::modelGeneVar(Tcells)\nHVGs &lt;- scran::getTopHVGs(Tcells_variance, prop = 0.2)\nrowData(Tcells)$isHVG &lt;- rownames(Tcells) %in% HVGs\n\n# Embedding dataset in PCA space and removing technical variance\nset.seed(1000)\nTcells &lt;- scran::denoisePCA(\n    Tcells, \n    technical = Tcells_variance, \n    subset.row = HVGs, \n    min.rank = 15\n)\n\n# Embedding dataset in shared k-nearest neighbors graph for clustering \ngraph &lt;- scran::buildSNNGraph(Tcells, k = 5, use.dimred = 'PCA', type = 'jaccard')\n\n# Cluster cells using Louvain community finding algorithm\nTcells_clust &lt;- igraph::cluster_louvain(graph)$membership\ntable(Tcells_clust)\nTcells$subclusters_graph &lt;- factor(Tcells_clust)\ntable(Tcells$subclusters_graph, Tcells$clusters_graph)\n\n# Embedding dataset in t-SNE space for visualization\nset.seed(1000)\nTcells &lt;- scater::runTSNE(Tcells, name = 'subTSNE')\n\n# Visualize earlier clustering and new clustering \np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(Tcells, dimred = 'TSNE', colour_by = 'clusters_graph', text_by = 'clusters_graph') + ggtitle('T cells, original tSNE, original clusters'),\n    scater::plotReducedDim(Tcells, dimred = 'subTSNE', colour_by = 'clusters_graph', text_by = 'clusters_graph') + ggtitle('T cells, new tSNE, original clusters'),\n    scater::plotReducedDim(Tcells, dimred = 'subTSNE', colour_by = 'subclusters_graph', text_by = 'subclusters_graph') + ggtitle('T cells, new tSNE, new clusters')\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nRe-tranfer annotations from Monaco et al.¬†to only T cells\nDoes re-transferring annotations on a subset of cells change the annotation obtained for each individual cell?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nTcells_predictions_main &lt;- SingleR::SingleR(\n    test = Tcells, \n    ref = monaco, \n    labels = monaco$label.main\n)\nTcells_predictions_fine &lt;- SingleR::SingleR(\n    test = Tcells, \n    ref = monaco, \n    labels = monaco$label.fine\n)\nTcells$subannotation_hierarchy_1 &lt;- Tcells_predictions_main$labels\nTcells$subannotation_hierarchy_2 &lt;- Tcells_predictions_fine$labels\ntable(Tcells$subannotation_hierarchy_1, Tcells$annotation_hierarchy_1)\ntable(Tcells$subannotation_hierarchy_2, Tcells$annotation_hierarchy_2)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCompare the subclusters to transferred annotations. Does subclustering help better representing the heterogeneity of T cells?\nPropose alternative(s) to better resolve single-cell transcriptomes of T cells.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Visualize earlier clustering and new clustering \np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(Tcells, dimred = 'subTSNE', colour_by = 'subclusters_graph', text_by = 'subclusters_graph') + ggtitle('T cells, new tSNE, new clusters'), \n    scater::plotReducedDim(Tcells, dimred = 'subTSNE', colour_by = 'annotation_hierarchy_2') + ggtitle('T cells, new tSNE, transferred annotations')\n)\n\n# Compare T cells original clusters and new subclusters to transferred fine annotations\ntable(Tcells$annotation_hierarchy_2, Tcells$clusters_graph)\ntable(Tcells$subannotation_hierarchy_2, Tcells$subclusters_graph)\np &lt;- pheatmap::pheatmap(\n    log2(table(Assigned = Tcells$annotation_hierarchy_2, Cluster = Tcells$clusters_graph)+10), \n    color=colorRampPalette(c(\"white\", \"darkred\"))(101), \n    cluster_rows = FALSE, cluster_cols = FALSE\n)\np &lt;- pheatmap::pheatmap(\n    log2(table(Assigned = Tcells$annotation_hierarchy_2, Cluster = Tcells$subclusters_graph)+10), \n    color=colorRampPalette(c(\"white\", \"darkred\"))(101), \n    cluster_rows = FALSE, cluster_cols = FALSE\n)"
  },
  {
    "objectID": "Demonstration/Day5_demonstration.html#trajectories-in-wt-mccs",
    "href": "Demonstration/Day5_demonstration.html#trajectories-in-wt-mccs",
    "title": "Demonstration: Trajectory inference and pseudotime",
    "section": "1. Trajectories in WT MCCs",
    "text": "1. Trajectories in WT MCCs\n\n# Load data \nMCCs &lt;- readRDS('data/MCCs/MCCs_processed.rds')\nCcnoKO &lt;- readRDS('data/MCCs/CcnoKO_processed.rds')\n# Infer lineages \nlibrary(slingshot)\nMCCs_slingshot &lt;- slingshot(\n    MCCs,\n    reducedDim = 'PCA', \n    clusterLabels = 'annotation', \n    start.clus = 'CyclingProgenitors', \n    end.clus = 'MCCs', \n    approx_points = 60\n)\nslingLineages(MCCs_slingshot)\n\n# Plot individual lineage tracing\nMCCs_slingData &lt;- embedCurves(MCCs_slingshot, \"corrected_UMAP\")\nMCCs$slingshot1 &lt;- colData(MCCs_slingshot)[, 'slingPseudotime_1']\nMCCs$slingshot2 &lt;- colData(MCCs_slingshot)[, 'slingPseudotime_2']\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(MCCs, \"corrected_UMAP\", colour_by = 'slingshot1', text_by = 'annotation') +\n        geom_path(\n            data = setNames(as.data.frame(slingCurves(MCCs_slingData)[[1]]$s[slingCurves(MCCs_slingData)[[1]]$ord,]), c('X', 'Y')),\n            mapping = aes(x = X, y = Y), \n            inherit.aes = FALSE, size = 2\n        ), \n    scater::plotReducedDim(MCCs, \"corrected_UMAP\", colour_by = 'slingshot2', text_by = 'annotation') +\n        geom_path(\n            data = setNames(as.data.frame(slingCurves(MCCs_slingData)[[2]]$s[slingCurves(MCCs_slingData)[[2]]$ord,]), c('X', 'Y')),\n            mapping = aes(x = X, y = Y), \n            inherit.aes = FALSE, size = 2\n        )\n)\nggsave('data/MCCs/WTs-trajectories.pdf', w = 10, h = 5)"
  },
  {
    "objectID": "Demonstration/Day5_demonstration.html#infer-a-single-trajectory-for-wt-ccnoko-mccs",
    "href": "Demonstration/Day5_demonstration.html#infer-a-single-trajectory-for-wt-ccnoko-mccs",
    "title": "Demonstration: Trajectory inference and pseudotime",
    "section": "2. Infer a single trajectory for WT + CcnoKO MCCs",
    "text": "2. Infer a single trajectory for WT + CcnoKO MCCs\n\nBl6J_WT &lt;- readRDS('data/MCCs/Bl6J_WT.rds')\nBl6N_WT &lt;- readRDS('data/MCCs/Bl6N_WT.rds')\nCcnoKO &lt;- readRDS('data/MCCs/CcnoKO.rds')\n\n# Merge all datasets together \nBl6J_WT$sample &lt;- 'WT'\nBl6N_WT$sample &lt;- 'WT'\nCcnoKO$sample &lt;- 'KO'\nrowData(CcnoKO) &lt;- rowData(CcnoKO)[, c(1:7)]\nrowData(Bl6J_WT) &lt;- rowData(CcnoKO)  \nrowData(Bl6N_WT) &lt;- rowData(CcnoKO)  \nmergedSCEs &lt;- cbind(Bl6J_WT, Bl6N_WT, CcnoKO)\nmergedSCEs &lt;- scuttle::logNormCounts(mergedSCEs)\nreducedDim(mergedSCEs, 'PCA') &lt;- scater::calculatePCA(mergedSCEs)\n\n# Find markers in WT cells\nmarkers &lt;- scran::findMarkers(\n    mergedSCEs, \n    groups = factor(mergedSCEs$annotation), \n    pval.type = \"any\"\n) %&gt;% lapply(function(x) {\n        as.data.frame(x) %&gt;% \n        arrange(desc(summary.logFC)) %&gt;%\n        rownames_to_column('marker') %&gt;% \n        '['(, 1:5) %&gt;% \n        filter(summary.logFC &gt; log2(2) & p.value &lt; 0.05) %&gt;%\n        pull(marker)\n}) %&gt;% do.call(c, .) %&gt;% unique()\n\n# Correct samples assuming they are all the same\nmergedSCEs_corrected &lt;- batchelor::fastMNN(\n    mergedSCEs, \n    batch = paste0(mergedSCEs$sample, '_', mergedSCEs$batch),\n    d = 50,\n    k = 15, \n    correct.all = TRUE,\n    subset.row = which(rownames(mergedSCEs) %in% markers),\n    BSPARAM = BiocSingular::RandomParam(deferred = TRUE)\n)\nreducedDim(mergedSCEs, 'PCA_corrected') &lt;- reducedDim(mergedSCEs_corrected, 'corrected')\nreducedDim(mergedSCEs, 'UMAP_corrected') &lt;- scater::calculateUMAP(mergedSCEs, dimred = \"PCA_corrected\")\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(mergedSCEs, \"PCA_corrected\", colour_by = 'annotation', text_by = 'annotation') + ggtitle('bound WTs + CcnoKO, corrected PCA, clusters'),\n    scater::plotReducedDim(mergedSCEs, \"PCA_corrected\", colour_by = 'sample', text_by = 'sample') + ggtitle('bound WTs + CcnoKO, corrected PCA, samples'),\n    scater::plotReducedDim(mergedSCEs, \"PCA_corrected\", colour_by = 'batch', text_by = 'batch') + ggtitle('bound WTs + CcnoKO, corrected PCA, genotypes'),\n    scater::plotReducedDim(mergedSCEs, \"UMAP_corrected\", colour_by = 'annotation', text_by = 'annotation') + ggtitle('bound WTs + CcnoKO, corrected UMAP, clusters'),\n    scater::plotReducedDim(mergedSCEs, \"UMAP_corrected\", colour_by = 'sample', text_by = 'sample') + ggtitle('bound WTs + CcnoKO, corrected UMAP, samples'),\n    scater::plotReducedDim(mergedSCEs, \"UMAP_corrected\", colour_by = 'batch', text_by = 'batch') + ggtitle('bound WTs + CcnoKO, corrected UMAP, genotypes'),\n    ncol = 3\n)\n\n# Slingshot TI\nmergedSCEs &lt;- mergedSCEs[, !is.na(mergedSCEs$annotation)]\nreducedDim(mergedSCEs, 'PCA_corrected_2') &lt;- reducedDim(mergedSCEs, 'PCA_corrected')[, 1:48]\nmergedSCEs_slingshot &lt;- slingshot(\n    mergedSCEs, \n    reducedDim = 'PCA_corrected_2',\n    clusterLabels = 'annotation', \n    start.clus = 'CyclingProgenitors', \n    end.clus = 'MCCs', \n    approx_points = 30\n)\nslingLineages(mergedSCEs_slingshot)\n\n# Plot individual lineage tracing\nmergedSCEs_slingData &lt;- embedCurves(mergedSCEs_slingshot, \"UMAP_corrected\")\nmergedSCEs$slingshot1 &lt;- pathStats(mergedSCEs_slingData)[[1]][, 'Lineage1']\np &lt;- scater::plotReducedDim(mergedSCEs, \"UMAP_corrected\", colour_by = 'slingshot1', text_by = 'annotation') +\n    geom_path(\n        data = setNames(as.data.frame(slingCurves(mergedSCEs_slingData)[[1]]$s[slingCurves(mergedSCEs_slingData)[[1]]$ord,]), c('X', 'Y')),\n        mapping = aes(x = X, y = Y), \n        inherit.aes = FALSE, size = 2\n    )\nggsave('data/MCCs/joint-WT-CcnoKO-trajectory.pdf')"
  },
  {
    "objectID": "Demonstration/Day5_demonstration.html#perform-de-expression-analysis-on-a-portion-of-the-trajectory",
    "href": "Demonstration/Day5_demonstration.html#perform-de-expression-analysis-on-a-portion-of-the-trajectory",
    "title": "Demonstration: Trajectory inference and pseudotime",
    "section": "3. Perform DE expression analysis on a portion of the trajectory",
    "text": "3. Perform DE expression analysis on a portion of the trajectory\nFilter cells based on 99% max of pseudotime_slingshot for CcnoKO\n\nthreshold &lt;- quantile(mergedSCEs$slingshot1[mergedSCEs$sample == 'KO'], 0.99, na.rm = TRUE)\nmergedSCEs_subset &lt;- mergedSCEs[, mergedSCEs$slingshot1 &lt;= threshold & !is.na(mergedSCEs$slingshot1)]\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(mergedSCEs_subset, \"UMAP_corrected\", colour_by = 'sample', text_by = 'sample') + ggtitle('bound WTs + CcnoKO, UMAP'),\n    scater::plotReducedDim(mergedSCEs_subset, \"UMAP_corrected\", colour_by = 'batch', text_by = 'batch') + ggtitle('bound WTs + CcnoKO, UMAP'),\n    scater::plotReducedDim(mergedSCEs_subset, \"UMAP_corrected\", colour_by = 'annotation', text_by = 'annotation') + ggtitle('bound WTs + CcnoKO, UMAP'), \n    ncol = 2\n)\n\nRunning tradeSeq using new slingshot pseudotimes\nUsing counts, blocking on genotype, with WTs/CcnoKO as a condition.\n\ncounts &lt;- as.matrix(assay(mergedSCEs_subset, 'counts'))\npseudotime &lt;- data.frame(\"1\" = mergedSCEs_subset$slingshot1)\ncellWeights &lt;- data.frame(\"1\" = rep(1, ncol(mergedSCEs_subset)))\ntradeSeq_res &lt;- tradeSeq::fitGAM(\n    counts = counts, \n    pseudotime = pseudotime,  \n    cellWeights = cellWeights, \n    U = as.matrix(data.frame(\n        'genotype' = as.numeric(factor(mergedSCEs_subset$batch))\n    )), \n    conditions = factor(mergedSCEs_subset$sample, c('WT', 'KO')), \n    parallel = FALSE\n)\ncondRes &lt;- tradeSeq::conditionTest(tradeSeq_res, l2fc = log2(1.5))"
  },
  {
    "objectID": "Exercises/Day5_exercises.html#prepare-data-from-scratch",
    "href": "Exercises/Day5_exercises.html#prepare-data-from-scratch",
    "title": "Exercises: Trajectory inference and RNA velocity",
    "section": "0. Prepare data from scratch",
    "text": "0. Prepare data from scratch\nBecause RNA velocity reflects the balance between immature and mature transcript content in each cell, one need to count the reads overlapping both spliced regions and unspliced regions. These counts are still generally not available when using public datasets. A way to generate them is to:\n\nGet a cellranger-generated bam file of a scRNAseq experiment\nGet the corresponding gene annotation file as a gtf file\nRun velocyto to count reads mapped to introns or to exons\n\nLet‚Äôs do this on a dataset published by Guo et al., Cell Res. 2018 (doi: 10.1038/s41422-018-0099-2). There are 6 bam files corresponding to human male testis single-cell RNA-seq profiling (GSE: GSE112013).\n\n\n\n\n\n\nQuestion\n\n\n\n\nDownload bam files from GEO\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmkdir data/Guo_testis/\nffq -t GSE \"GSE112013\" | grep 'ftp://' | sed 's,.*ftp:,ftp:,' | sed 's,\".*,,' &gt; data/Guo_testis/GSE112013_bam-list.txt\nfor FILE in `cat data/Guo_testis/GSE112013_bam-list.txt | sed '$d'`\ndo\n    echo $FILE\n    curl ${FILE} -o data/Guo_testis/`basename ${FILE}`\ndone\n\n\n\n\n\n\nTo run velocyto, one needs to know where introns and exons are located in the genome reference used to process reads. In our case, GRCh38 genome reference was used.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead cellranger instructions on how to generate a gtf file corresponding to GRCh38 genome reference here.\nCreate GRCh38 gene annotation gtf file following Cellranger recommendations\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmkdir data/Guo_testis/genome\ncurl http://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_32/gencode.v32.primary_assembly.annotation.gtf.gz -o data/Guo_testis/genome/gencode.v32.primary_assembly.annotation.gtf.gz\ngunzip data/Guo_testis/genome/gencode.v32.primary_assembly.annotation.gtf.gz\nID=\"(ENS(MUS)?[GTE][0-9]+)\\.([0-9]+)\"\ncat data/Guo_testis/genome/gencode.v32.primary_assembly.annotation.gtf \\\n    | sed -E 's/gene_id \"'\"$ID\"'\";/gene_id \"\\1\"; gene_version \"\\3\";/' \\\n    | sed -E 's/transcript_id \"'\"$ID\"'\";/transcript_id \"\\1\"; transcript_version \"\\3\";/' \\\n    | sed -E 's/exon_id \"'\"$ID\"'\";/exon_id \"\\1\"; exon_version \"\\3\";/' \\\n    &gt; data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_modified.gtf\ncat data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_modified.gtf \\\n    | awk '$3 == \"transcript\"' \\\n    | grep -E \"$GENE_PATTERN\" \\\n    | grep -E \"$TX_PATTERN\" \\\n    | grep -Ev \"$READTHROUGH_PATTERN\" \\\n    | grep -Ev \"$PAR_PATTERN\" \\\n    | sed -E 's/.*(gene_id \"[^\"]+\").*/\\1/' \\\n    | sort \\\n    | uniq \\\n    &gt; data/Guo_testis/genome/gene_allowlist\ngrep -E \"^#\" data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_modified.gtf &gt; data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_filtered.gtf\ngrep -Ff data/Guo_testis/genome/gene_allowlist data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_modified.gtf \\\n    | sed -E 's,^chr,,' \\\n    | sed -E 's,^M\\t,MT\\t,' \\\n    &gt;&gt; data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_filtered.gtf\n\n\n\n\n\n\nTo make the velocyto step faster, one can only use reads from bam files originating from cell-containing droplets. One way to do so is to extract cell barcodes from the already filtered scRNAseq dataset, and use them in the -b argument of velocyto.\n\n\n\n\n\n\nQuestion\n\n\n\n\n(Optional) Get cell barcodes from cellranger (this requires pre-processed scRNAseq data, available from GEO)\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(tidyverse) \nvroom::vroom('data/Guo_testis/GSE112013_Combined_UMI_table.txt') %&gt;% \n    colnames() %&gt;% \n    str_replace_all('Donor.-', '') %&gt;% \n    tail(-1) %&gt;% \n    unique() %&gt;%\n    writeLines('data/Guo_testis/testis_cell-barcodes.txt')\n\n\n\n\n\n\nBy now, we have obtained 3 different files:\n\nBAM files of scRNAseq data mapped onto GRCh38\nGTF file of GRCh38 gene annotations\nA barcode file for BAM file pre-filtering\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nRun velocyto on each sample\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmkdir data/Guo_testis/velocyto\nfor FILE in `cat data/Guo_testis/GSE112013_bam-list.txt`\ndo\n    curl ${FILE} -o data/Guo_testis/`basename ${FILE}`\n    velocyto run \\\n        -b data/Guo_testis/testis_cell-barcodes.txt \\\n        -o data/Guo_testis/velocyto/ \\\n        --samtools-threads 15 \\\n        -vv \\\n        data/Guo_testis/`basename ${FILE}` \\\n        data/Guo_testis/genome/gencode.v32.primary_assembly.annotation_filtered.gtf\n    rm data/Guo_testis/`basename ${FILE}`\ndone\n\n\n\n\n\n\nWe have obtained six loom files, but ideally we want them merged as a single SingleCellExperiment object readable in R.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead about LoomExperiment package. Is there an easy (and reliable) way to import loom files in R?\nMerge loom files directly in R and save the resulting object as a rds binary file.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(LoomExperiment)\nlooms &lt;- list.files('data/Guo_testis/velocyto/', full.names = TRUE) %&gt;% \n    lapply(LoomExperiment::import) %&gt;% \n    do.call(cbind, .)\nlooms$sample &lt;- str_replace_all(looms$CellID, ':.*', '')\nlooms$Barcode &lt;- str_replace_all(looms$CellID, '.*:', '') %&gt;% str_replace('x', '')\n# Some additional tidying up... \n# testis_2 &lt;- testis[rownames(testis)[rownames(testis) %in% rowData(looms)$Gene], ]\n# genes &lt;- rownames(testis_2)\n# bcs &lt;- testis_2$Barcode\n# looms &lt;- looms[match(genes, rowData(looms)$Gene), ]\n# looms &lt;- scuttle::aggregateAcrossCells(looms, looms$Barcode, use.assay.type = c('spliced', 'unspliced'))\n# looms &lt;- looms[, match(bcs, looms$Barcode)]\n#\nsaveRDS(looms, 'data/Guo_testis/testis_velocity-counts.rds')"
  },
  {
    "objectID": "Exercises/Day5_exercises.html#process-testis-data-in-r",
    "href": "Exercises/Day5_exercises.html#process-testis-data-in-r",
    "title": "Exercises: Trajectory inference and RNA velocity",
    "section": "1. Process testis data in R",
    "text": "1. Process testis data in R\nThe same workflow than previous days can be reused here.\n\n\n\n\n\n\nQuestion\n\n\n\n\nImport testis dataset in R, filter cells and genes, normalize counts, embed data and cluster cells.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(SingleCellExperiment)\nlibrary(tidyverse)\ndownload.file(\n    'https://ftp.ncbi.nlm.nih.gov/geo/series/GSE112nnn/GSE112013/suppl/GSE112013_Combined_UMI_table.txt.gz', \n    'data/Guo_testis/GSE112013_Combined_UMI_table.txt.gz'\n)\nsystem('gunzip data/Guo_testis/GSE112013_Combined_UMI_table.txt.gz')\nx &lt;- vroom::vroom('data/Guo_testis/GSE112013_Combined_UMI_table.txt')\ncnts &lt;- as.matrix(x[, -1])\ngData &lt;- as.data.frame(x[, 1])\ncData &lt;- data.frame(cellid = colnames(x[, -1]))\ntestis &lt;- SingleCellExperiment(\n    assays = list(counts = cnts), \n    colData = cData, \n    rowData = gData\n)\ntestis$Barcode &lt;- str_replace(testis$cellid, 'Donor.-', '') %&gt;% str_replace('-.', '')\ntestis &lt;- testis[, !duplicated(testis$Barcode)]\ntestis$donor &lt;- str_replace(testis$cellid, '-.*', '')\ntestis$replicate &lt;- str_replace(testis$cellid, '.*-', '')\nrownames(testis) &lt;- rowData(testis)$Gene\nset.seed(1000)\n\n# Remove doublets\ntestis &lt;- scDblFinder::scDblFinder(testis)\ntestis &lt;- testis[, testis$scDblFinder.class == 'singlet']\n\n# Recover human genomic, protein-coding gene informations\nlibrary(plyranges)\nah &lt;- AnnotationHub::AnnotationHub()\nAnnotationHub::query(ah, c('gene annotation', 'ensembl', '102', 'homo_sapiens', 'GRCh38'))\ngtf &lt;- AnnotationHub::query(ah, c('Homo_sapiens.GRCh38.102.chr.gtf'))[[1]]\ngenes &lt;- gtf %&gt;% \n    filter(type == 'gene') %&gt;% \n    filter(gene_biotype == 'protein_coding') %&gt;% \n    filter(gene_source == 'ensembl_havana') \ngenes &lt;- genes[!duplicated(genes$gene_name)]\n\n# Annotate genes in testis dataset and filter out non-relevant genes\ntestis &lt;- testis[genes$gene_name[genes$gene_name %in% rownames(testis)], ]\nrowRanges(testis) &lt;- genes[match(rownames(testis), genes$gene_name)]\nrowData(testis) &lt;- rowData(testis)[, c('gene_name', 'gene_id')]\nrownames(testis) &lt;- scuttle::uniquifyFeatureNames(rowData(testis)$gene_id, rowData(testis)$gene_name)\n\n# Get preliminary QCs per cell and per gene\ntestis &lt;- scuttle::addPerCellQCMetrics(testis)\ntestis &lt;- scuttle::addPerFeatureQCMetrics(testis)\n\n# Filter out genes not expressed in at least 10 cells\ntestis &lt;- testis[rowSums(assay(testis, 'counts') &gt; 0) &gt;= 10, ]\n\n# Normalize counts using VST\ncnts &lt;- as(assay(testis, 'counts'), 'dgCMatrix')\ncolnames(cnts) &lt;- testis$cellid\nrownames(cnts) &lt;- rownames(testis)\ntestis_vst &lt;- sctransform::vst(cnts, return_cell_attr = TRUE)\ncorrected_cnts &lt;- sctransform::correct(testis_vst)\nassay(testis, 'corrected_counts', withDimnames = FALSE) &lt;- corrected_cnts\nassay(testis, 'logcounts', withDimnames = FALSE) &lt;- log1p(corrected_cnts)\n\n# Computing biological variance of each gene\ntestis_variance &lt;- scran::modelGeneVar(testis)\nHVGs &lt;- scran::getTopHVGs(testis_variance, prop = 0.1)\nrowData(testis)$isHVG &lt;- rownames(testis) %in% HVGs\n\n# Embedding dataset in PCA space, correcting for batch effect\nmergedBatches &lt;- batchelor::fastMNN(\n    testis, \n    batch = testis$donor, \n    subset.row = HVGs, \n    BPPARAM = BiocParallel::MulticoreParam(workers = 12)\n)\nreducedDim(testis, 'corrected') &lt;- reducedDim(mergedBatches, 'corrected')\n\n# Embedding dataset in shared k-nearest neighbors graph for clustering \ngraph &lt;- scran::buildSNNGraph(testis, use.dimred = 'corrected')\n\n# Cluster cells using Louvain community finding algorithm\ntestis_clust &lt;- igraph::cluster_louvain(graph)$membership\ntable(testis_clust)\ntestis$cluster &lt;- factor(testis_clust)\n\n# Embedding dataset in TSNE space for visualization\nset.seed(10)\ntestis &lt;- scater::runTSNE(testis, dimred = 'corrected')\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(testis, 'corrected', colour_by = 'donor'),\n    scater::plotReducedDim(testis, 'corrected', colour_by = 'cluster'),\n    scater::plotReducedDim(testis, 'TSNE', colour_by = 'donor'),\n    scater::plotReducedDim(testis, 'TSNE', colour_by = 'cluster')\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nLoad HPA data from internet. Try to format it as a SummarizedExperiment. What celltypes are profiled?\nUse these cell type profiles to annotate cell types in the testis dataset.\nHow do the annotations look like? Can you find a reason why the label transfer worked so well?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndownload.file(\n    'https://www.proteinatlas.org/download/rna_single_cell_type.tsv.zip', \n    'data/Guo_testis/rna_single_cell_type.tsv.zip'\n)\nsystem('unzip data/Guo_testis/rna_single_cell_type.tsv.zip')\nsystem('mv rna_single_cell_type.tsv data/Guo_testis/')\nHPA &lt;- vroom::vroom('data/Guo_testis/rna_single_cell_type.tsv') %&gt;% \n    pivot_wider(names_from = `Cell type`, values_from = 'NX') %&gt;% \n    dplyr::select(-Gene) %&gt;% \n    distinct(`Gene name`, .keep_all = TRUE) %&gt;% \n    column_to_rownames('Gene name') %&gt;% \n    SummarizedExperiment::SummarizedExperiment(assays = list('logcounts' = .))\n\n# Transfer annotations to `testis`\npredictions &lt;- SingleR::SingleR(\n    test = testis, \n    ref = HPA, \n    labels = colnames(HPA)\n)\ntable(predictions$labels, testis$cluster)\nlabels &lt;- table(predictions$labels, testis$cluster) %&gt;% \n    data.matrix() %&gt;% \n    apply(2, which.max) %&gt;% \n    sort(unique(predictions$labels))[.]\nnames(labels) &lt;- 1:length(labels)\ntestis$annotation &lt;- labels[testis$cluster]\np &lt;- cowplot::plot_grid(\n    scater::plotReducedDim(testis, dimred = 'corrected', colour_by = 'cluster', text_by = 'cluster') + ggtitle('Testis data, PCA, graph-based clusters'), \n    scater::plotReducedDim(testis, dimred = 'corrected', colour_by = 'annotation', text_by = 'annotation') + ggtitle('PCA, Annotations transferred from HPA'),\n    scater::plotReducedDim(testis, dimred = 'TSNE', colour_by = 'cluster', text_by = 'cluster') + ggtitle('Testis data, tSNE, graph-based clusters'), \n    scater::plotReducedDim(testis, dimred = 'TSNE', colour_by = 'annotation', text_by = 'annotation') + ggtitle('tSNE, Annotations transferred from HPA')\n)"
  },
  {
    "objectID": "Exercises/Day5_exercises.html#trajectory-inference-ti-in-scrnaseq",
    "href": "Exercises/Day5_exercises.html#trajectory-inference-ti-in-scrnaseq",
    "title": "Exercises: Trajectory inference and RNA velocity",
    "section": "2. Trajectory inference (TI) in scRNAseq",
    "text": "2. Trajectory inference (TI) in scRNAseq\nAn important question in scRNAseq field of research is: how to identify a cell trajectory from high-dimensional expression data and map individual cells onto it? A large number of methods have currently emerged, each one with their own specificities, assumptions, and strengths. A nice breakdown (from 2019, so already very outdated!) is available from Saelens et al., Nat. Biotech. 2018 (doi: 10.1038/s41587-019-0071-9):\n\nSlingshot\nSlingshot is perhaps one of the most widely used algorithms for users who want to focus on R-based approaches.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead Slingshot documentation to understand how to identify lineages in a scRNAseq dataset in R\nInfer lineages in the testis dataset\nWhy is it recommended to infer lineages from PCA space rather than t-SNE or UMAP space, even though these spaces do ‚Äúreveal‚Äù an obvious trajectory in 2D?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ntestis_slingshot &lt;- slingshot::slingshot(testis, reducedDim = 'corrected')\ntestis_slingshot\nslingshot::slingLineages(testis_slingshot)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCheck the inferred trajectory(ies) in 2D projection. You can use the embedCurves() to embed the curves in any given dimensional space. Do they fit your expectations?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npca_curve &lt;- slingCurves(testis_slingshot, as.df = TRUE)\ncolnames(pca_curve) &lt;- paste0('PC', 1:ncol(pca_curve))\ntsne_curve &lt;- slingshot::embedCurves(testis_slingshot, 'TSNE', smoother = 'loess', span = 0.1) %&gt;% slingCurves(as.df = TRUE)\ntsne_curve &lt;- tsne_curve[order(tsne_curve$Order), ]\ncolnames(tsne_curve)[1:2] &lt;- paste0('TSNE', 1:ncol(tsne_curve))\ndf &lt;- tibble(\n    PC1 = reducedDim(testis, 'corrected')[,1], \n    PC2 = reducedDim(testis, 'corrected')[,2], \n    TSNE1 = reducedDim(testis, 'TSNE')[,1], \n    TSNE2 = reducedDim(testis, 'TSNE')[,2], \n    cluster = testis$cluster\n)\np &lt;- cowplot::plot_grid(\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(PC1, PC2, col = cluster)) + \n        geom_path(data = pca_curve, aes(x = PC1, y = PC2)) + \n        theme_bw() + \n        coord_fixed(),\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(TSNE1, TSNE2, col = cluster)) + \n        geom_path(data = tsne_curve, aes(x = TSNE1, y = TSNE2)) + \n        theme_bw() + \n        coord_fixed()\n)\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nFilter the testis dataset to only germinal cells.\nRe-infer lineages, using cluster annotations as information to build the MST. Note that you will first need to remove the 50th PCA dimension for slingshot to work (bug reported).\nWhat do you observe? Discuss.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngermcells &lt;- testis[, testis$annotation %in% c(\"Spermatogonia\", \"Spermatocytes\", \"Early spermatids\", \"Late spermatids\")]\nreducedDim(germcells, 'corrected_2') &lt;- reducedDim(germcells, 'corrected')[, 1:49]\ngermcells_slingshot &lt;- slingshot::slingshot(\n    germcells, \n    reducedDim = 'corrected_2', \n    clusterLabels = germcells$cluster\n)\ngermcells$pseudotime &lt;- slingshot::slingPseudotime(germcells_slingshot)[, 'Lineage1']\n\npca_curve &lt;- slingCurves(germcells_slingshot, as.df = TRUE)\ncolnames(pca_curve) &lt;- paste0('PC', 1:ncol(pca_curve))\ntsne_curve &lt;- slingshot::embedCurves(germcells_slingshot, 'TSNE', smoother = 'loess', span = 0.1) %&gt;% slingCurves(as.df = TRUE)\ntsne_curve &lt;- tsne_curve[order(tsne_curve$Order), ]\ncolnames(tsne_curve) &lt;- paste0('TSNE', 1:ncol(tsne_curve))\ndf &lt;- tibble(\n    PC1 = reducedDim(germcells, 'corrected')[,1], \n    PC2 = reducedDim(germcells, 'corrected')[,2], \n    TSNE1 = reducedDim(germcells, 'TSNE')[,1], \n    TSNE2 = reducedDim(germcells, 'TSNE')[,2], \n    cluster = germcells$cluster, \n    pseudotime = germcells$pseudotime\n)\np &lt;- cowplot::plot_grid(\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(PC1, PC2, col = cluster)) + \n        geom_path(data = pca_curve, aes(x = PC1, y = PC2)) + \n        theme_bw() + \n        coord_fixed(),\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(TSNE1, TSNE2, col = cluster)) + \n        geom_path(data = tsne_curve, aes(x = TSNE1, y = TSNE2)) + \n        theme_bw() + \n        coord_fixed(),\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(PC1, PC2, col = pseudotime)) + \n        geom_path(data = pca_curve, aes(x = PC1, y = PC2)) + \n        theme_bw() + \n        coord_fixed(),\n    df %&gt;% \n        ggplot() + \n        geom_point(aes(TSNE1, TSNE2, col = pseudotime)) + \n        geom_path(data = tsne_curve, aes(x = TSNE1, y = TSNE2)) + \n        theme_bw() + \n        coord_fixed()\n)\n\n\n\n\n\n\nPseudotime inference and expression modelling\nThe pseudotime is a metric describing the relative position of a cell in the trajectory, where cells with larger values are consider to be ‚Äúafter‚Äù their counterparts with smaller values. In trajectories describing time-dependent processes like differentiation, a cell‚Äôs pseudotime value is generally used as a proxy for its relative age.\nPseudotime inference\n\n\n\n\n\n\nQuestion\n\n\n\n\nExtract the pseudotime values automatically computed by slingshot.\nCheck the distribution of pseudotime values across the different cell clusters. What do you observe? Where you expecting this?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\np &lt;- tibble(\n    annotation = factor(germcells$annotation, c(\"Spermatogonia\", \"Spermatocytes\", \"Early spermatids\", \"Late spermatids\")), \n    pseudotime = germcells$pseudotime\n) %&gt;% \n    ggplot(aes(x = annotation, y = pseudotime, fill = annotation)) + \n    geom_violin(scale = 'width') + \n    geom_boxplot(outlier.shape = NULL, width = 0.1, fill = 'white') + \n    theme_bw() + \n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) \n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nCorrect pseudotime values as you would expect it to be.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngermcells$pseudotime &lt;- scales::rescale((-1 * slingshot::slingPseudotime(germcells_slingshot)[, 'Lineage1']), c(0, 1))"
  },
  {
    "objectID": "Exercises/Day5_exercises.html#ordering-trajectory-with-rna-velocity",
    "href": "Exercises/Day5_exercises.html#ordering-trajectory-with-rna-velocity",
    "title": "Exercises: Trajectory inference and RNA velocity",
    "section": "3. Ordering trajectory with RNA velocity",
    "text": "3. Ordering trajectory with RNA velocity\nAs we saw earlier, TI does not necessarily know which direction is right for a given trajectory. This can be safely estimated using RNA velocity. For a given gene, a high ratio of unspliced to spliced transcripts indicates that that gene is being actively upregulated. Conversely, a low ratio indicates that the gene is being downregulated as the rate of production and processing of pre-mRNAs cannot compensate for the degradation of mature transcripts. Thus, we can infer that cells with high and low ratios are moving towards a high- and low-expression state, respectively, allowing us to assign directionality to trajectories or even individual cells.\n\n\n\n\n\n\nQuestion\n\n\n\n\nRead velociraptor documentation. What do you need to compute RNA velocity scores in R?\nImport spliced and unspliced counts computed with velocyto in R.\nTry and compute RNA velocity (on germcells only). What do you see?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlooms &lt;- readRDS('data/Guo_testis/testis_velocity-counts.rds')\nassays(looms)\nrownames(looms) &lt;- rowData(looms)$Gene\ntestis &lt;- testis[rownames(looms), ]\nassay(testis, 'spliced', withDimnames=FALSE) &lt;- assay(looms, 'spliced')\nassay(testis, 'unspliced', withDimnames=FALSE) &lt;- assay(looms, 'unspliced')\ngermcells &lt;- testis[, testis$annotation %in% c(\"Spermatogonia\", \"Spermatocytes\", \"Early spermatids\", \"Late spermatids\")]\nvelo_out &lt;- velociraptor::scvelo(\n    germcells, \n    assay.X = \"counts\", \n    use.dimred = \"corrected\", \n    subset.row = scran::getTopHVGs(scran::modelGeneVar(germcells), prop = 0.1), \n    mode = 'dynamical'\n)\nembedded_velo &lt;- velociraptor::embedVelocity(reducedDim(germcells, \"TSNE\"), velo_out)\ngrid.df &lt;- velociraptor::gridVectors(reducedDim(germcells, \"TSNE\"), embedded_velo, resolution = 30)\np &lt;- scater::plotReducedDim(germcells, 'TSNE', colour_by = \"annotation\", point_alpha = 0.5) +\n    geom_segment(\n        data = grid.df, \n        mapping = aes(x = start.1, y = start.2, xend = end.1, yend = end.2), \n        arrow = arrow(length = unit(0.05, \"inches\"), type = \"closed\")\n    )"
  },
  {
    "objectID": "pages/resources.html#general-bioinformatics",
    "href": "pages/resources.html#general-bioinformatics",
    "title": "Appendix A ‚Äî Useful resources",
    "section": "General bioinformatics",
    "text": "General bioinformatics\n\nA comprehensive overview of the different types of bioinformatic analyses, divided in 4 fundamental modules: LINK"
  },
  {
    "objectID": "pages/resources.html#rbioconductor",
    "href": "pages/resources.html#rbioconductor",
    "title": "Appendix A ‚Äî Useful resources",
    "section": "R/Bioconductor",
    "text": "R/Bioconductor\n\nThe excellent R guide for beginners, by Emmanuel Paradis: PDF\nThe 150+ pages comprehensive book to learn everything about Bioconductor. This ebook has been published by Kasper D. Hansen and is freely available under the CC BY-NC-SA 4.0 license: PDF\nA digested PowerPoint summarizing two R/Bioconductor fundamental classes: GRanges and *Experiment classes"
  },
  {
    "objectID": "pages/resources.html#scientific-readings",
    "href": "pages/resources.html#scientific-readings",
    "title": "Appendix A ‚Äî Useful resources",
    "section": "Scientific readings",
    "text": "Scientific readings\n\n2014 Nat. Methods paper from Bioconductor core team describing important object classes\nTo see from how far Bioc comes from..."
  }
]